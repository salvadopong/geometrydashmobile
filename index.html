<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Dash V20.0: The Ultimate Edition</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <style>
        /* FAVICON NOTE: The browser expects a physical file named 'favicon.ico' in the root directory. 
           For this single-file HTML, the link tag is here, but the file content must be created externally. */

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --primary: #00f0ff;
            --secondary: #ff0055;
            --bg: #121212;
            --panel: rgba(10, 10, 20, 0.98); 
            --font-main: 'Orbitron', sans-serif;
            --player-main: #00f0ff;
            --player-sec: #ff0055;
            --accent-green: #00ff00;
            --dash-color: #ffff00; /* New color for dash */
            --slow-color: #8800ff; /* New color for slowness */
            --tile-size: 50px;
        }
        
        body {
            margin: 0; overflow: hidden; background-color: var(--bg);
            font-family: var(--font-main); color: white; user-select: none;
        }

        #game-container { position: relative; width: 100vw; height: 100vh; background: #000; }
        canvas { display: block; width: 100%; height: 100%; }

        /* --- UI LAYERS & MENUS (Redesigned for Polish) --- */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: 0.4s ease-out; z-index: 10;
        }
        .hidden { opacity: 0; pointer-events: none; transform: scale(0.95) translateY(20px); }
        .visible { opacity: 1; pointer-events: auto; transform: scale(1) translateY(0); } 

        .menu-box {
            background: var(--panel); padding: 40px; border-radius: 16px; 
            border: 4px solid var(--primary); 
            box-shadow: 0 0 80px rgba(0, 240, 255, 0.4), inset 0 0 20px rgba(0, 240, 255, 0.1); 
            text-align: center; min-width: 450px; /* Slightly wider */
        }

        @keyframes pulse {
            0% { text-shadow: 0 0 5px var(--primary); }
            50% { text-shadow: 0 0 25px var(--primary), 0 0 40px rgba(0, 240, 255, 0.7); }
            100% { text-shadow: 0 0 5px var(--primary); }
        }

        h1 {
            font-size: 4rem; margin: 0 0 10px 0; text-transform: uppercase;
            background: linear-gradient(to bottom, #ffffff, var(--primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: pulse 2s infinite alternate;
        }
        h2 { color: var(--primary); text-shadow: 0 0 8px rgba(0, 240, 255, 0.5); }


        button {
            background: linear-gradient(180deg, #333333, #111111);
            border: 2px solid #555; color: #fff;
            padding: 18px 35px; 
            font-family: var(--font-main); font-size: 1.3rem; 
            margin: 12px; cursor: pointer; text-transform: uppercase; font-weight: bold;
            box-shadow: 0 6px 0 #000; transition: all 0.15s;
            border-radius: 8px;
        }
        button:active { transform: translateY(6px); box-shadow: 0 0 0 #000; }
        button:hover { border-color: var(--primary); color: var(--primary); background: #222; }
        
        button.secondary { background: linear-gradient(180deg, #500, #300); }
        button.secondary:hover { border-color: var(--secondary); color: var(--secondary); }
        
        button.next { background: linear-gradient(180deg, #0c0, #060); border-color: #0f0; }
        button.next:hover { color: #0f0; }

        /* Level Select Redesign */
        #menu-levels .menu-box { min-width: 600px; }
        .level-paged-container {
            display: flex; align-items: center; justify-content: center;
            margin-bottom: 20px;
        }
        .level-grid {
            display: grid; grid-template-columns: repeat(5, 1fr); /* 5x2 grid */
            gap: 15px; margin: 0 20px;
        }
        .lvl-btn {
            background: #222; color: #fff; border: 3px solid #555;
            width: 80px; height: 80px; display: flex; align-items: center; justify-content: center;
            font-size: 1.8rem; font-weight: bold; border-radius: 12px; cursor: pointer;
            box-shadow: 0 4px 0 rgba(0,0,0,0.5); transition: all 0.1s;
        }
        .lvl-btn:hover { border-color: var(--primary); background: #333; }
        .lvl-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 rgba(0,0,0,0.5); }
        .lvl-btn.locked {
            background: #080808; color: #333; border-color: #1a1a1a; cursor: default;
            pointer-events: none;
        }
        .lvl-btn.locked:hover { background: #080808; }
        .nav-arrow {
            width: 60px; height: 60px; font-size: 2rem; padding: 0; margin: 0 10px;
        }

        /* Shop Redesign */
        #shop-content {
            display: grid; grid-template-columns: repeat(4, 1fr); 
            gap: 15px; max-width: 800px; margin-bottom: 20px;
        }
        .costume-item {
            background: #222; padding: 10px; border-radius: 10px; border: 3px solid #333;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); transition: transform 0.15s, border-color 0.15s;
            cursor: pointer;
        }
        .costume-item:hover { transform: translateY(-3px); border-color: var(--primary); }
        .costume-item.equipped {
            border-color: var(--accent-green);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.7);
        }
        .player-preview-cube {
            width: 40px; height: 40px; margin: 10px auto; display: flex;
            border: 3px solid; /* Use secondary color */
            position: relative;
        }

        /* HUD - More vivid */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none;
            font-weight: bold; text-shadow: 0 0 5px #000;
        }
        #att, #coin-count span { color: var(--primary); text-shadow: 0 0 8px var(--primary); }
        #coin-count { position: absolute; top:15px; right:20px; font-size:1.4rem; }
        .progress-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 70%; height: 15px; background: rgba(255,255,255,0.1); border: 2px solid #fff;
            border-radius: 7px; overflow: hidden;
        }
        .progress-fill { height: 100%; background: linear-gradient(to right, var(--primary), var(--secondary)); width: 0%; transition: width 0.1s linear; }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute; bottom: 0; right: 0; display: none; padding: 10px;
            z-index: 5; /* Above HUD, below menus */
        }
        .show-mobile #mobile-controls { display: flex; }
        .mobile-btn {
            width: 80px; height: 80px; border-radius: 15px;
            margin: 10px; font-size: 2rem; font-weight: bold;
            display: flex; justify-content: center; align-items: center;
            opacity: 0.8; transition: opacity 0.1s;
        }
        #mobile-action {
            background: var(--primary); color: var(--bg);
            box-shadow: 0 0 15px var(--primary);
        }
        #mobile-reset {
            background: var(--secondary); color: #fff;
            box-shadow: 0 0 15px var(--secondary);
        }
        .mobile-btn:active { opacity: 1; transform: scale(0.95); }
        
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="msg" style="position: absolute; top: 80px; left: 50%; transform: translateX(-50%); font-size: 2rem; opacity: 0; transition: opacity 0.3s;">MODE</div>
        <div id="tutorial-msg" style="display: none; position: absolute; top: 120px; left: 50%; transform: translateX(-50%); font-size: 1.2rem; color: #ff0; text-shadow: 0 0 10px #ff0;"></div>

        <div id="hud">
            <div style="position: absolute; top:15px; left:20px; font-size:1.4rem;">ATTEMPT <span id="att">1</span></div>
            <div class="progress-bar"><div class="progress-fill" id="prog"></div></div>
            <div id="coin-count">ðŸ’°<span id="coin-count-val">0</span></div>
        </div>
        
        <div id="mobile-controls">
            <div id="mobile-action" class="mobile-btn" 
                 ontouchstart="Input.touchStartAction(event)" 
                 ontouchend="Input.touchEndAction(event)"
            >JUMP</div>
            <div id="mobile-reset" class="mobile-btn" 
                 ontouchstart="Game.retry(event)" 
            >R</div>
        </div>

        <div id="menu-main" class="ui-layer visible">
            <div class="menu-box">
                <h1>NEON DASH</h1>
                <p style="letter-spacing:5px; color:#888; font-size:0.9rem; margin-top:-10px; text-shadow: 0 0 5px #000;">V20.0 - ULTIMATE</p>
                <button onclick="UI.startPlay()">Play Levels</button>
                <button onclick="UI.showShop()">Shop</button>
                
                <div style="margin-top:15px; font-size: 0.9rem; color:#888;">
                    Controls: **Space/â†‘** (Action), **R** (Reset)
                </div>
                <div style="margin-top:5px; font-size: 0.9rem; color:#aaa;">
                    Levels unlocked: <span id="unlock-count">1</span>/50 | Coins: ðŸ’°<span id="menu-coins">0</span>
                </div>
            </div>
        </div>

        <div id="menu-levels" class="ui-layer hidden">
            <div class="menu-box">
                <h2>SELECT LEVEL</h2>
                <div class="level-paged-container">
                    <button id="level-prev" class="nav-arrow" onclick="UI.changeLevelPage(-1)" disabled>&#9664;</button>
                    <div class="level-grid" id="lvl-grid"></div>
                    <button id="level-next" class="nav-arrow" onclick="UI.changeLevelPage(1)" disabled>&#9654;</button>
                </div>
                <button onclick="UI.home()">BACK</button>
            </div>
        </div>

        <div id="menu-shop" class="ui-layer hidden">
            <div class="menu-box">
                <h2>CUBE SHOP</h2>
                <div style="font-size: 1.4rem; margin-bottom: 20px;">Your Coins: ðŸ’°<span id="shop-coins">0</span></div>
                <div id="shop-content"></div>
                <button onclick="UI.home()">BACK</button>
            </div>
        </div>

        <div id="menu-pause" class="ui-layer hidden">
            <div class="menu-box">
                <h1 id="pause-title" style="font-size: 2.5rem;">CRASHED</h1>
                <p id="pause-p" style="font-size: 1.5rem; color:#fff;">0%</p>
                <button id="pause-main-btn" onclick="Game.retry()">RETRY (R Key)</button>
                <button class="secondary" onclick="UI.home()">MENU</button>
            </div>
        </div>
    </div>

<script>
// --- CONFIGURATION ---
const CFG = {
    g: 0.8,       
    jmp: 15.0,    
    spd: 8.5,     
    term: 18,     
    tile: 50,
    TILE_SEP_FACTOR: 2, 
    MINI_SCALE: 0.6, 
    MACRO_SCALE: 1.0, 
    maxHeight: -1000, 
    START_X: 30, 
    PAD_JUMP: 40, 
    TOTAL_LEVELS: 50, 
    LEVELS_PER_PAGE: 10, 
    SWING_GRAB_DIST: 10, 
    SWING_FORCE: 25, 
    DASH_DIST: 300, // Distance cube dashes
    SLOW_FACTOR: 0.4 // Factor to slow speed by
};

// --- GLOBAL STATE ---
let unlocked = parseInt(localStorage.getItem('nd_level') || 1);
let totalCoins = parseInt(localStorage.getItem('nd_coins') || 0);
let unlockedSkins = JSON.parse(localStorage.getItem('nd_skins') || '[0]');
let equippedSkinIndex = parseInt(localStorage.getItem('nd_equipped_skin') || 0);
let tutorialDone = localStorage.getItem('nd_tutorial_done') === 'true';
let currentPage = 1;

// --- THEME DATA (unchanged) ---
const THEMES = [
    [80, 200, 15], [100, 120, 20], [120, 60, 25], [140, 0, 30], [160, 270, 35], 
    [180, 330, 40], [200, 180, 45], [220, 240, 50], [240, 0, 80]    
];

// --- SKINS/COSTUMES (unchanged) ---
const SKINS = [
    { name: "Default Neon", cost: 0, main: '#00f0ff', secondary: '#ff0055' },
    { name: "Fire Cube", cost: 10, main: '#ff0000', secondary: '#ffaa00' },
    { name: "Electric Purple", cost: 25, main: '#9d00ff', secondary: '#00ffaa' },
    { name: "Shadow Black", cost: 50, main: '#111111', secondary: '#ffffff' },
    { name: "Gold Plated", cost: 100, main: '#ffd700', secondary: '#aa5500' },
    { name: "Acid Green", cost: 150, main: '#00ff00', secondary: '#ffff00' },
    { name: "Deep Space", cost: 200, main: '#000088', secondary: '#88aaff' },
    { name: "Sun Burst", cost: 300, main: '#ffaa00', secondary: '#ff0000' }, 
    { name: "Crystal Blue", cost: 400, main: '#00aaff', secondary: '#00ffaa' },
];

// --- AUDIO (unchanged) ---
const AUDIO = { 
    ctx: null, bgmLoop: false, currentBGM: null, 
    init: function() { 
        if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)(); 
    },
    tone: function(f, t, d, v=0.1, s=0) { 
        if(!this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type=t; o.frequency.value=f; 
        if(s) o.frequency.linearRampToValueAtTime(s, this.ctx.currentTime+d);
        g.gain.setValueAtTime(v, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime+d);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime+d);
    },
    jump: () => AUDIO.tone(100, 'square', 0.1, 0.1),
    die: () => AUDIO.tone(80, 'sawtooth', 0.4, 0.2, 10),
    orb: () => AUDIO.tone(600, 'sine', 0.1, 0.1, 1200),
    pad: () => AUDIO.tone(300, 'square', 0.2, 0.1, 800),
    coin: () => AUDIO.tone(1000, 'sine', 0.05, 0.2, 1200),
    win: () => { AUDIO.tone(440,'triangle',0.1); setTimeout(()=>AUDIO.tone(554,'triangle',0.1),100); setTimeout(()=>AUDIO.tone(660,'triangle',0.4),200); },
    gravity: () => AUDIO.tone(500, 'sine', 0.1, 0.3, 200),
    checkpoint: () => AUDIO.tone(700, 'triangle', 0.1, 0.2, 1400),
    dash: () => AUDIO.tone(1500, 'square', 0.08, 0.3),
    slow: () => AUDIO.tone(100, 'sine', 0.5, 0.2),
    startBGM: function(freq) { 
        if(!this.ctx) return;
        this.stopBGM();
        this.currentBGM = this.ctx.createOscillator();
        this.currentBGM.type = 'triangle';
        this.currentBGM.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        const gainNode = this.ctx.createGain();
        gainNode.gain.setValueAtTime(0.05, this.ctx.currentTime);
        
        this.currentBGM.connect(gainNode);
        gainNode.connect(this.ctx.destination);
        this.currentBGM.start();
        this.bgmLoop = true;
    },
    stopBGM: function() { 
        if (this.currentBGM) {
            this.currentBGM.stop();
            this.currentBGM = null;
            this.bgmLoop = false;
        }
    }
};

// Helper function to create obstacle arrays with better spacing
const createObstacle = (t, x, y) => ({t:t, x:x * CFG.TILE_SEP_FACTOR, y:y});

// --- HAND-CRAFTED LEVEL DATA (V20 REDESIGN) ---
const L = createObstacle; 
const S = CFG.TILE_SEP_FACTOR; 

const createLevel = (idx, objects) => {
    let level = [...objects];
    
    // Find the max X value in the current level definition
    const maxX = level.reduce((max, obj) => Math.max(max, obj.x * S), 0);
    
    // Ensure the goal is right at the end (Fix 2)
    level.push(L(99, Math.ceil(maxX / S) + 20, 0)); 
    
    // Add extra coins EVERYWHERE for polish
    // Simple vertical coin stacks
    for (let i = 40 * S; i < maxX; i += 15 * S) {
        if (Math.random() < 0.6) {
            level.push(L(3, Math.ceil(i/S), 1)); 
        }
    }

    return level;
};


const LEVELS = [
    // 0. The Basics (Cube, Pad, Coin, Dash Intro) - Now demands continuous jump (Fix 10)
    createLevel(0, [
        L(1,40,0), L(3,40,1), L(1,41,0), L(7,45,0), L(3,45,1), L(7,50,0), L(1,55,0), L(2,60,0), L(3,60,1), L(1,65,0), L(2,67,0), L(1,70,0), L(15,75,2), L(3,75,3), L(1,77,2), L(2,80,0), L(1,85,0), 
    ]),
    // 1. Ship Launch (Flappy Bird Style) - Narrow corridor flight (Fix 7)
    createLevel(1, [
        L(1,40,0), L(3,40,1), L(4,45,1), L(3,45,2), L(2,48,0), L(2,48,5), L(3,50,2), L(4,52,1), L(2,55,0), L(2,55,5), L(3,57,3), L(4,60,1), L(2,63,0), L(2,63,5), L(3,65,4), L(4,70,1), L(2,73,0), L(2,73,5), L(3,75,3), L(4,80,1), L(2,83,0), L(2,83,5), L(3,85,4), L(4,89,1), L(2,92,0), L(2,92,5), L(3,94,4), L(4,97,1),
    ]),
    // 2. Gravity Loop (G block sticks to Ceiling) - Inverted spikes and timing (Fix 9)
    createLevel(2, [
        L(1,40,0), L(3,40,1), L(8,50,2), L(3,50,3), L(2,55,4), L(3,55,3), L(1,60,4), L(3,60,3), L(2,65,4), L(1,70,4), L(3,70,3), L(3,75,1), L(8,80,2), L(3,80,3), L(1,85,0), L(3,85,1), L(2,90,0), L(1,95,0), L(3,95,1), L(8,100,2), L(3,100,3), L(1,105,4), L(3,105,3), L(2,110,4), L(6,115,4), L(3,115,3), L(1,120,0), L(3,120,1), 
    ]),
    // 3. Mini Hurdles & Dash - Quick precision and forced Dash (Fix 5)
    createLevel(3, [
        L(1,40,0), L(3,40,1), L(9,43,1), L(3,43,2), L(2,45,0), L(1,47,0), L(2,49,0), L(1,51,0), L(2,53,0), L(1,55,0), L(2,57,0), L(1,59,0), L(15,62,1), L(3,62,2), L(2,65,0), L(1,67,0), L(1,70,0), L(3,70,1), L(1,73,0), L(2,75,0), L(1,77,0), L(1,80,0), L(3,80,1), L(2,82,0), L(1,85,0), L(15,88,1), L(3,88,2), L(1,90,0), L(2,93,0), L(1,95,0), L(3,95,1),
    ]),
    // 4. UFO Floater & Slowness - Timing through large gaps (Fix 5)
    createLevel(4, [
        L(1,40,0), L(3,40,1), L(5,45,2), L(3,45,3), L(1,50,0), L(3,50,1), L(16,55,2), L(3,55,3), L(1,60,4), L(3,60,3), L(1,65,0), L(3,65,1), L(1,70,4), L(3,70,3), L(16,75,2), L(3,75,3), L(1,80,0), L(3,80,1), L(1,85,4), L(3,85,3), L(1,90,0), L(3,90,1), L(16,95,2), L(3,95,3), L(1,100,4), L(3,100,3), L(6,105,2), L(3,105,3), L(1,110,0), L(3,110,1), 
    ]),
    // 5. Robot Leap & Continuous Jump - Large, spaced jumps
    createLevel(5, [
        L(1,40,0), L(3,40,1), L(12,45,0), L(3,45,1), L(1,50,0), L(3,50,1), L(2,55,0), L(1,60,0), L(3,60,1), L(2,65,0), L(1,70,0), L(3,70,1), L(2,75,0), L(1,80,0), L(3,80,1), L(2,85,0), L(1,90,0), L(3,90,1), L(2,95,0), L(6,100,0), L(3,100,1), L(1,105,0), L(3,105,1), L(2,110,0), L(1,115,0), L(3,115,1),
    ]),
    // 6. Wave Tunnel & Narrow Flight - Horizontal flow
    createLevel(6, [
        L(1,40,0), L(3,40,1), L(11,43,0), L(3,43,1), L(1,46,3), L(3,46,2), L(1,49,1), L(3,49,2), L(1,52,4), L(3,52,3), L(1,55,1), L(3,55,2), L(1,58,3), L(3,58,4), L(1,61,1), L(3,61,2), L(1,64,4), L(3,64,3), L(1,67,1), L(3,67,2), L(1,70,3), L(3,70,4), L(1,73,1), L(3,73,2), L(3,76,2), L(6,80,0), L(3,80,1), L(1,83,0), L(3,83,1), L(2,86,0), L(11,90,0), L(3,90,1),
    ]),
    // 7. Mini Ship Maze (Flappy Bird) - Tight corridors, high speed
    createLevel(7, [
        L(1,40,0), L(3,40,1), L(9,42,1), L(4,45,1), L(3,45,2), L(2,47,3), L(3,47,4), L(2,49,3), L(3,49,4), L(2,51,3), L(3,51,4), L(2,53,3), L(3,53,4), L(2,55,3), L(3,55,4), L(2,57,3), L(3,57,4), L(2,59,3), L(3,59,4), L(2,61,3), L(3,61,4), L(2,63,3), L(3,63,4), L(2,65,3), L(3,65,4), L(6,68,1), L(3,68,2), L(10,70,1), L(1,73,0), L(3,73,1), L(2,76,0), L(4,80,1), L(3,80,2),
    ]),
    // 8. UFO Gravity Flip & Dash - Quick inverted movement, forced Dash (Fix 5)
    createLevel(8, [
        L(1,40,0), L(3,40,1), L(5,45,2), L(3,45,3), L(8,50,2), L(3,50,3), L(1,55,4), L(3,55,3), L(1,60,4), L(3,60,3), L(8,65,2), L(3,65,3), L(1,70,0), L(3,70,1), L(15,75,2), L(3,75,3), L(8,80,2), L(3,80,3), L(1,85,4), L(3,85,3), L(1,90,4), L(3,90,3), L(3,95,2), L(6,100,0), L(3,100,1), L(1,105,0), L(3,105,1), L(2,110,0), L(5,115,2), L(3,115,3),
    ]),
    // 9. Everything Gauntlet - Mixing all modes (excluding slow/dash)
    createLevel(9, [
        L(1,40,0), L(3,40,1), L(12,43,0), L(3,43,1), L(9,46,0), L(3,46,1), L(1,49,0), L(3,49,1), L(2,52,0), L(11,55,0), L(3,55,1), L(1,58,2), L(3,58,3), L(4,61,2), L(3,61,3), L(1,64,4), L(3,64,3), L(6,67,0), L(3,67,1), L(10,70,0), L(1,73,0), L(3,73,1), L(7,76,0), L(3,76,1), L(2,79,0), L(4,82,0), L(3,82,1), L(1,85,3), L(3,85,4), L(6,88,0), L(3,88,1), L(1,91,0), L(3,91,1),
    ]),

    // --- NEW V20 LEVELS with Dash/Slow/Continuous Jump ---
    
    // 10. Dash Trial (Cube) - Timing ground obstacles with quick Dash moves
    createLevel(10, [
        L(1,40,0), L(3,40,1), L(1,45,0), L(3,45,1), L(15,50,1), L(2,55,0), L(1,60,0), L(3,60,1), L(15,65,1), L(2,70,0), L(1,75,0), L(3,75,1), L(15,80,1), L(2,85,0), L(1,90,0), L(3,90,1), L(15,95,1), L(2,100,0), L(1,105,0), L(3,105,1), L(1,110,0), L(3,110,1),
    ]),
    // 11. The Slowdown Chamber (Cube) - Jumping through the new Slow Portal (Type 16)
    createLevel(11, [
        L(1,40,0), L(3,40,1), L(1,45,0), L(3,45,1), L(16,50,2), L(2,55,0), L(1,60,0), L(3,60,1), L(16,65,2), L(2,70,0), L(1,75,0), L(3,75,1), L(16,80,2), L(2,85,0), L(1,90,0), L(3,90,1), L(16,95,2), L(2,100,0), L(1,105,0), L(3,105,1), L(1,110,0), L(3,110,1),
    ]),
    // 12. UFO Downhill (Ship) - Flappy bird style, but with sloped blocks
    createLevel(12, [
        L(1,40,0), L(3,40,1), L(4,45,1), L(3,45,2), L(2,48,0), L(2,48,5), L(3,50,2), L(4,53,1), L(2,56,0), L(2,56,5), L(3,59,3), L(4,62,1), L(2,65,0), L(2,65,5), L(3,68,4), L(4,71,1), L(2,74,0), L(2,74,5), L(3,77,3), L(4,80,1), L(2,83,0), L(2,83,5), L(3,86,4), L(4,89,1), L(2,92,0), L(2,92,5), L(3,95,4), L(4,98,1),
    ]),
    // 13. Robot Leap & Dash - Requires a dash jump for a large gap
    createLevel(13, [
        L(1,40,0), L(3,40,1), L(12,45,0), L(3,45,1), L(1,50,0), L(3,50,1), L(15,55,2), L(2,60,0), L(1,65,0), L(3,65,1), L(15,70,2), L(2,75,0), L(1,80,0), L(3,80,1), L(15,85,2), L(2,90,0), L(1,95,0), L(3,95,1), L(2,100,0), L(12,105,0), L(3,105,1),
    ]),
    // 14. Wave and Ship Transition & Slowdown
    createLevel(14, [
        L(1,40,0), L(3,40,1), L(11,43,1), L(3,43,2), L(16,46,2), L(1,49,3), L(3,49,4), L(4,52,1), L(3,52,2), L(16,55,2), L(1,58,3), L(3,58,4), L(11,61,1), L(3,61,2), L(16,64,2), L(1,67,3), L(3,67,4), L(4,70,1), L(3,70,2), L(16,73,2), L(11,76,1), L(3,76,2),
    ]),

    // --- PLACEHOLDERS FOR LEVELS 15 - 49 (Extended length and added more coins) ---
    ...Array(35).fill(0).map((_, i) => createLevel(15 + i, [
        L(1,40,0), L(3,40,1), L(1,45,2), L(3,45,3), L(2,50,0), L(3,50,1), L(3,60,1), L(7,70,0), L(3,70,1), L(1,80,3), L(3,80,4), L(1,90,0), L(3,90,1), L(2,100,0), L(3,100,1), L(15,110,2), L(3,110,3), L(1,120,0), L(3,120,1), L(16,130,2), L(3,130,3), L(1,140,0), L(3,140,1),
    ])),

    // 50. Final Gauntlet - All modes, all portals, max length
    createLevel(49, [
        L(1,40,0), L(3,40,1), L(9,43,1), L(3,43,2), L(1,45,3), L(16,48,2), L(4,50,1), L(3,52,2), L(8,55,2), L(12,60,0), L(15,65,2), L(1,70,0), L(3,70,1), L(11,75,1), L(4,80,1), L(14,85,0), L(3,87,1), L(1,90,0), L(10,95,1), L(5,100,2), L(8,105,2), L(6,110,0), L(16,115,2), L(1,120,0), L(15,125,2), L(3,128,1), L(1,130,0), L(2,135,0), L(1,140,0), L(3,140,1)
    ])
];


// --- ENGINE ---
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    state: 'menu', 
    level: [], 
    att: 1, 
    camX: 0, 
    floorY: 0,
    shake: 0,
    currLvlIdx: 0,
    pauseBtn: document.getElementById('pause-main-btn'),
    bgHue: 200, 
    bgSat: 15,  
    isMobile: window.innerWidth <= 768, 
    goalX: 100000, 
    startPos: { x: CFG.START_X * CFG.tile, y: 0, g: CFG.g, mode: 'cube', scale: CFG.MACRO_SCALE },
    currentCheckpoint: null,
    timeScale: 1.0, 
    dashActive: false,

    init: function() {
        this.resize();
        window.onresize = ()=>this.resize();
        document.getElementById('unlock-count').innerText = unlocked;
        document.getElementById('unlock-count').parentElement.innerHTML = `Levels unlocked: <span id="unlock-count">${unlocked}</span>/${CFG.TOTAL_LEVELS}`;
        Player.loadColors();
        this.updateCoinDisplay();
        AUDIO.init();
        this.checkMobileControls();
        this.loop();
    },
    updateCoinDisplay: function() {
        document.getElementById('coin-count-val').innerText = totalCoins;
        if(document.getElementById('menu-coins')) document.getElementById('menu-coins').innerText = totalCoins;
        if(document.getElementById('shop-coins')) document.getElementById('shop-coins').innerText = totalCoins;
        localStorage.setItem('nd_coins', totalCoins);
    },
    resize: function() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.floorY = this.canvas.height - 150;
        this.isMobile = window.innerWidth <= 768;
        this.checkMobileControls();
    },
    checkMobileControls: function() {
        if (this.isMobile && this.state === 'game') {
            document.getElementById('game-container').classList.add('show-mobile');
        } else {
            document.getElementById('game-container').classList.remove('show-mobile');
        }
    },
    loadLevel: function(idx) {
        if(idx < 0 || idx >= LEVELS.length) return;
        this.currLvlIdx = idx;
        
        const themeIdx = idx % THEMES.length; 
        const theme = THEMES[themeIdx];
        this.bgHue = theme[1];
        this.bgSat = theme[2];
        
        this.level = JSON.parse(JSON.stringify(LEVELS[idx])); 
        this.currentCheckpoint = null;
        this.startPos = { x: CFG.START_X * CFG.tile, y: 0, g: CFG.g, mode: 'cube', scale: CFG.MACRO_SCALE };
        this.timeScale = 1.0;
        this.start(theme[0]); 
    },
    start: function(bgmFreq) {
        this.state = 'game';
        Player.reset();
        this.camX = 0;
        this.att = 1; 
        document.getElementById('att').innerText = this.att;
        UI.hide();
        document.getElementById('hud').style.display = 'block';
        AUDIO.startBGM(bgmFreq);
        this.checkMobileControls(); 
        
        const goalObject = this.level.find(o => o.t === 99);
        this.goalX = goalObject ? goalObject.x * CFG.tile : 100000;

        if(this.currLvlIdx === 0 && !tutorialDone) { 
            this.showTutorialMessage("Hold JUMP for continuous jumps! Double Tap to DASH!", 5000);
            tutorialDone = true;
            localStorage.setItem('nd_tutorial_done', 'true');
        }
    },
    showTutorialMessage: function(message, duration) {
        const msgEl = document.getElementById('tutorial-msg');
        msgEl.innerText = message;
        msgEl.style.display = 'block';
        if (duration) {
            setTimeout(() => {
                if(msgEl.innerText === message) msgEl.style.display = 'none';
            }, duration);
        }
    },
    retry: function(e) { 
        if(e) e.preventDefault(); 
        if (this.state === 'game' || this.state === 'dead' || this.state === 'win') {
            this.state = 'game';
            
            Player.reset(this.currentCheckpoint); 

            this.att++;
            document.getElementById('att').innerText = this.att;
            UI.hide();
            document.getElementById('tutorial-msg').style.display = 'none';
            this.checkMobileControls(); 
            this.timeScale = 1.0;
            
            if(!this.currentCheckpoint) {
                 this.level = JSON.parse(JSON.stringify(LEVELS[this.currLvlIdx]));
            } else {
                 this.level = this.currentCheckpoint.levelState;
            }
            
            const goalObject = this.level.find(o => o.t === 99);
            this.goalX = goalObject ? goalObject.x * CFG.tile : 100000;
        }
    },
    setCheckpoint: function(x, y, g, mode, scale) {
        this.currentCheckpoint = {
            x: x, 
            y: y, 
            g: g, 
            mode: mode, 
            scale: scale,
            levelState: JSON.parse(JSON.stringify(this.level)) 
        };
        AUDIO.checkpoint();
        this.showTutorialMessage("Checkpoint Saved!", 2000);
    },
    win: function() {
        if (this.state === 'game') {
            this.state = 'win';
            AUDIO.win();
            AUDIO.stopBGM();
            
            if (this.currLvlIdx + 2 > unlocked) {
                unlocked = this.currLvlIdx + 2;
                localStorage.setItem('nd_level', unlocked);
                document.getElementById('unlock-count').innerText = unlocked;
            }
            
            document.getElementById('pause-title').innerText = `LEVEL ${this.currLvlIdx + 1} COMPLETE!`;
            document.getElementById('pause-p').innerText = `Time: ${(this.att - 1) * 0.05}s (Attempts: ${this.att})`;
            
            this.pauseBtn.innerText = `NEXT LEVEL ${this.currLvlIdx + 2}`;
            this.pauseBtn.classList.add('next');
            this.pauseBtn.onclick = () => {
                if (this.currLvlIdx + 1 < LEVELS.length) {
                    Game.loadLevel(this.currLvlIdx + 1);
                } else {
                    alert('Congratulations! You beat all current levels!');
                    UI.home();
                }
            };

            UI.show('menu-pause');
        }
    },
    crash: function() {
        if (this.state === 'game' || this.state === 'dash') {
            this.state = 'dead';
            this.shake = 10;
            this.timeScale = 1.0;
            Game.dashActive = false;
            
            AUDIO.die();
            AUDIO.stopBGM();
            
            let percentage = Math.floor(((Player.x - (this.currentCheckpoint ? this.currentCheckpoint.x : CFG.START_X * CFG.tile)) / (this.goalX - (this.currentCheckpoint ? this.currentCheckpoint.x : CFG.START_X * CFG.tile))) * 100);
            percentage = Math.max(0, Math.min(100, percentage));
            
            document.getElementById('pause-title').innerText = 'CRASHED!';
            document.getElementById('pause-p').innerText = `${percentage}%`;
            this.pauseBtn.innerText = 'RETRY (R Key)';
            this.pauseBtn.classList.remove('next');
            this.pauseBtn.onclick = () => Game.retry();
            
            UI.show('menu-pause');
        }
    },
    
    loop: function() {
        let ctx = this.ctx;
        
        let hue = this.bgHue;
        if (this.bgSat > 30) hue = (this.bgHue + (Player.x / 20) % 360) % 360; 
        
        ctx.fillStyle = `hsl(${hue}, ${this.bgSat}%, 10%)`;
        ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
        
        ctx.save();
        if(this.shake>0) {
            ctx.translate((Math.random()-.5)*this.shake, (Math.random()-.5)*this.shake);
            this.shake*=0.9;
        }
        
        // Vertical flip for inverted gravity
        if(Player.g < 0) {
            ctx.scale(1, -1);
            ctx.translate(0, -this.canvas.height); 
        }

        if(this.state === 'game') {
            Player.update();
            this.camX = Player.x - 300;
        } 

        let targetY = Player.y * 0.6;
        let camY = (this.canvas.height - 150) - targetY; 
        
        // Background grid lines (unchanged)
        ctx.strokeStyle = `hsla(${hue}, 50%, 50%, 0.1)`;
        ctx.lineWidth = 2;
        let ox = -(this.camX % CFG.tile);
        for(let i=ox; i<this.canvas.width; i+=CFG.tile) {
            ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i-100, this.canvas.height); ctx.stroke();
        }
        
        // Floor drawing
        ctx.fillStyle = Player.mainColor;
        ctx.fillRect(0, camY, this.canvas.width, 4); 
        ctx.fillStyle = '#111';
        ctx.fillRect(0, camY+4, this.canvas.width, 500);

        this.level.forEach(o => {
            let dx = o.x * CFG.tile - this.camX;
            let oy = -(o.y * CFG.tile); 
            let dy = camY + oy - CFG.tile; 

            if(dx < -CFG.tile || dx > this.canvas.width) return;

            if(o.t===1) { /* Block */ ctx.fillStyle = `hsl(${hue}, 80%, 60%)`; ctx.fillRect(dx,dy,CFG.tile,CFG.tile); ctx.strokeStyle='rgba(255,255,255,0.8)'; ctx.lineWidth=3; ctx.strokeRect(dx,dy,CFG.tile,CFG.tile); ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(dx+5,dy+5,CFG.tile-10,CFG.tile-10); } 
            else if (o.t===2) { /* Spike */ ctx.fillStyle='#f55'; ctx.beginPath(); if (Player.g < 0 && Game.state === 'game') { ctx.moveTo(dx+10, dy); ctx.lineTo(dx+25, dy+45); ctx.lineTo(dx+40, dy); } else { ctx.moveTo(dx+10, dy+CFG.tile); ctx.lineTo(dx+25, dy+5); ctx.lineTo(dx+40, dy+CFG.tile); } ctx.fill(); ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke(); }
            else if (o.t===3) { /* Coin (Orb) */ ctx.fillStyle='#ff0'; ctx.beginPath(); ctx.arc(dx+25,dy+25,12,0,7); ctx.fill(); ctx.strokeStyle='#ff0'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(dx+25,dy+25,20,0,7); ctx.stroke(); }
            else if (o.t===7) { /* Pad (Bouncer) */ ctx.fillStyle='#0ff'; ctx.fillRect(dx+5, dy+40, 40, 10); ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.strokeRect(dx+5, dy+40, 40, 10); }
            else if (o.t===8) { /* Gravity Switch */ ctx.fillStyle='#55f'; ctx.fillRect(dx, dy, CFG.tile, CFG.tile); ctx.fillStyle='#fff'; ctx.font='30px Orbitron'; ctx.textAlign='center'; ctx.fillText('G', dx+25, dy+35); }
            
            // Mode Portals
            else if (o.t===4) { ctx.strokeStyle='#0f0'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Ship
            else if (o.t===5) { ctx.strokeStyle='#fa0'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // UFO
            else if (o.t===6) { ctx.strokeStyle='#fff'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Cube
            else if (o.t===11) { ctx.strokeStyle='#f55'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Wave
            else if (o.t===12) { ctx.strokeStyle='#0f5'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Robot
            else if (o.t===14) { ctx.strokeStyle='#ff00ff'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Swing/Spider
            else if (o.t===15) { ctx.strokeStyle=CFG.DASH_COLOR; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Dash
            else if (o.t===16) { ctx.strokeStyle=CFG.SLOW_COLOR; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100); } // Slow
            
            // Size Portals
            else if (o.t===9) { /* Mini */ ctx.fillStyle='#f80'; ctx.globalAlpha=0.3; ctx.fillRect(dx, dy+15, CFG.tile, 20); ctx.globalAlpha=1; ctx.strokeStyle='#f80'; ctx.lineWidth=2; ctx.strokeRect(dx+10, dy+10, 30, 30); }
            else if (o.t===10) { /* Macro */ ctx.fillStyle='#08f'; ctx.globalAlpha=0.3; ctx.fillRect(dx, dy+15, CFG.tile, 20); ctx.globalAlpha=1; ctx.strokeStyle='#08f'; ctx.lineWidth=2; ctx.strokeRect(dx+5, dy+5, 40, 40); }
            else if (o.t===13) { /* Checkpoint */ ctx.fillStyle='rgba(0, 255, 0, 0.2)'; ctx.fillRect(dx, -500, 10, 2000); ctx.strokeStyle='rgba(0, 255, 0, 0.8)'; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(dx, dy+CFG.tile-5); ctx.lineTo(dx + 10, dy+CFG.tile-5); ctx.stroke(); }
            else if (o.t===99) { /* Goal */ ctx.fillStyle='#0f0'; ctx.globalAlpha=0.3; ctx.fillRect(dx, -500, 100, 2000); ctx.globalAlpha=1; }
        });

        if(this.state !== 'dead') Player.draw(ctx, camY);

        if(this.state === 'game') {
            let endX = this.goalX;
            let startX = this.currentCheckpoint ? this.currentCheckpoint.x : CFG.START_X * CFG.tile;
            
            let p = Math.max(0, Math.min(100, ((Player.x - startX) / (endX - startX)) * 100));
            document.getElementById('prog').style.width = p+'%';
        }

        ctx.restore();
        requestAnimationFrame(()=>this.loop());
    }
};

// --- PLAYER PHYSICS ---
const Player = {
    x:0, y:0, w:40, h:40, 
    dx: CFG.spd, dy:0, 
    mode:'cube', angle:0, onGround:false,
    g: CFG.g,
    scale: CFG.MACRO_SCALE, 
    mainColor: '#00f0ff',
    secondaryColor: '#ff0055',
    waveAngle: 0, 
    isSwinging: false, 
    swingBlock: null,
    lastJumpTime: 0,
    dashTargetX: 0,

    loadColors: function() {
        const skin = SKINS[equippedSkinIndex];
        this.mainColor = skin.main;
        this.secondaryColor = skin.secondary;
        document.documentElement.style.setProperty('--player-main', this.mainColor);
        document.documentElement.style.setProperty('--player-sec', this.secondaryColor);
    },
    equipSkin: function(index) {
        equippedSkinIndex = index;
        localStorage.setItem('nd_equipped_skin', index);
        this.loadColors();
        UI.renderShop();
    },
    updateSize: function(newScale) {
        if(this.scale === newScale) return;
        let oldH = this.h;
        this.scale = newScale;
        this.w = 40 * this.scale;
        this.h = 40 * this.scale;
        if (this.g > 0) { this.y = this.y + (oldH - this.h); } 
        else { this.y = this.y - (oldH - this.h); }
        this.g = (CFG.g * newScale) * Math.sign(this.g);
    },

    reset: function(checkpoint) {
        if (checkpoint) {
            this.x = checkpoint.x; this.y = checkpoint.y; 
            this.g = checkpoint.g; this.scale = checkpoint.scale;
            this.mode = checkpoint.mode;
        } else {
            this.x = CFG.START_X * CFG.tile; this.y = 0; 
            this.g = CFG.g; this.scale = CFG.MACRO_SCALE;
            this.mode = 'cube';
        }
        
        this.dy=0; this.angle=0; 
        this.onGround=true;
        this.w = 40 * this.scale; this.h = 40 * this.scale;
        this.waveAngle = 0;
        this.isSwinging = false;
        this.swingBlock = null;
        this.dashTargetX = 0;
        Game.timeScale = 1.0;
        this.setMode(this.mode, true);
    },

    update: function() {
        if (this.x + this.w + this.dx > Game.goalX) { Game.win(); return; }

        const gravityFactor = this.scale * (this.g > 0 ? 1 : -1);
        const termScaled = CFG.term * this.scale;
        
        if (this.dashTargetX > this.x) {
            this.x += 60 * Game.timeScale; // Fixed high speed dash
            if (this.x >= this.dashTargetX) {
                this.x = this.dashTargetX;
                this.dashTargetX = 0;
                Game.dashActive = false;
                this.dx = CFG.spd * Game.timeScale;
            }
        } else {
            this.dx = CFG.spd * Game.timeScale;
        }

        if(this.dashTargetX === 0) { // Physics updates only when not dashing
            if(this.mode === 'cube' || this.mode === 'robot') {
                this.dy += CFG.g * gravityFactor * Game.timeScale;
                if(this.mode === 'cube') {
                    if(this.onGround) {
                        let r = Math.round(this.angle/(Math.PI/2))*(Math.PI/2);
                        this.angle += (r-this.angle)*0.25; 
                        
                        // Fix 10: Continuous Jump
                        if (Input.held) {
                            this.jump(true); 
                        }
                    } else {
                        this.angle += 0.18 * Math.sign(this.g) * Game.timeScale;
                    }
                } else { 
                    this.angle += (0-this.angle)*0.1;
                }
            } 
            else if (this.mode === 'ship' || this.mode === 'ufo') {
                if(Input.held) this.dy -= (this.mode === 'ship' ? 0.6 : 0.7) * gravityFactor * Game.timeScale; 
                else this.dy += (this.mode === 'ship' ? 0.5 : CFG.g) * gravityFactor * Game.timeScale; 
                this.angle = this.dy * 0.15;
            } 
            else if (this.mode === 'wave') {
                if(Input.held) this.waveAngle = 45 * Math.sign(this.g);
                else this.waveAngle = -45 * Math.sign(this.g);
                
                const waveSpeed = 8 * this.scale;
                const waveRad = this.waveAngle * (Math.PI / 180);
                this.dy = Math.sin(waveRad) * -waveSpeed * Game.timeScale; 
                
                this.angle = waveRad * 1.5;
                this.dy += this.g * 0.0001; 
            }
            else if (this.mode === 'swing') {
                if (this.isSwinging) {
                    this.dy += CFG.g * gravityFactor * Game.timeScale;
                } else {
                    this.dy += CFG.g * gravityFactor * Game.timeScale;
                }
                this.angle += (0-this.angle)*0.1; 
            }

            if (this.mode !== 'wave') {
                if(this.dy > termScaled) this.dy = termScaled;
                if(this.dy < -termScaled) this.dy = -termScaled;
            }
        }

        this.x += this.dx;
        this.checkCol(true);

        this.y += this.dy;
        this.onGround = false;

        const floorHeight = 0;
        const ceilingHeight = CFG.maxHeight;

        // Bounding box checks
        if(this.g > 0) { 
            if(this.y > floorHeight) { this.y = floorHeight; this.dy = 0; this.onGround = true; }
            if(this.y - this.h < ceilingHeight) { 
                if (this.mode === 'wave') { Game.crash(); } 
                else { this.y = ceilingHeight + this.h; this.dy = 0; } 
            } 
        } else { // Inverted Gravity
            if(this.y - this.h < ceilingHeight) { this.y = ceilingHeight + this.h; this.dy = 0; this.onGround = true; }
            if(this.y > floorHeight) { 
                if (this.mode === 'wave') { Game.crash(); } 
                else { this.y = floorHeight; this.dy = 0; } 
            }
        }
        
        if (this.mode === 'wave') {
            if(this.g > 0 && (this.y > floorHeight+1 || this.y - this.h < ceilingHeight-1)) Game.crash();
            if(this.g < 0 && (this.y - this.h < ceilingHeight-1 || this.y > floorHeight+1)) Game.crash();
        }

        this.checkCol(false);
    },

    checkCol: function(isX) {
        let l=this.x, r=this.x+this.w, t=this.y-this.h, b=this.y;
        
        for (let i = Game.level.length - 1; i >= 0; i--) {
            const o = Game.level[i];
            
            if(Math.abs(o.x*CFG.tile - this.x) > 100) continue; 

            let ox = o.x*CFG.tile, oy = -(o.y*CFG.tile);
            let ol = ox, or = ox+CFG.tile, ot = oy-CFG.tile, ob = oy;

            if(r>ol && l<or && b>ot && t<ob) {
                
                if(o.t===2) Game.crash();
                else if(o.t===3) { totalCoins++; AUDIO.coin(); Game.updateCoinDisplay(); Game.level.splice(i, 1); }
                else if(o.t===7 && Math.sign(this.dy) === Math.sign(this.g)) { 
                     // Fix 1: Spring now works
                     this.dy = (-CFG.PAD_JUMP * this.scale) * Math.sign(this.g) * -1; 
                     this.onGround=false; 
                     AUDIO.pad();
                }
                else if(o.t===13) { Game.setCheckpoint(this.x, this.y, this.g, this.mode, this.scale); Game.level.splice(i, 1); }
                
                // Fix 6: Portals trigger on simple collision (now checked on the solid block types)
                
                // Mode Portals
                else if(o.t===4) { this.setMode('ship'); Game.level.splice(i, 1); } 
                else if(o.t===5) { this.setMode('ufo'); Game.level.splice(i, 1); }
                else if(o.t===6) { this.setMode('cube'); Game.level.splice(i, 1); }
                else if(o.t===11) { this.setMode('wave'); Game.level.splice(i, 1); }
                else if(o.t===12) { this.setMode('robot'); Game.level.splice(i, 1); }
                else if(o.t===14) { this.setMode('swing'); Game.level.splice(i, 1); } 
                
                // New Ability Portals
                else if(o.t===15) { 
                    this.setMode('cube'); // Dash only applies to cube mode
                    this.dash(); 
                    Game.level.splice(i, 1); 
                } 
                else if(o.t===16) { 
                    Game.timeScale = CFG.SLOW_FACTOR;
                    AUDIO.slow();
                    this.dx = CFG.spd * Game.timeScale;
                    Game.showTutorialMessage("SLOW MOTION!", 1500);
                    Game.level.splice(i, 1);
                }

                // Gravity Switch (Fix 9: Stick to Ceiling/Wall)
                else if(o.t===8) { 
                    this.g *= -1;
                    this.g = Math.abs(CFG.g * this.scale) * Math.sign(this.g); 
                    
                    // FIX 9: If gravity is now negative, stick to the ceiling. If positive, stick to the floor.
                    if (this.g > 0) { // Normal gravity (Down) -> Stick to floor (Y=0)
                        this.y = 0; 
                    } else { // Inverted gravity (Up) -> Stick to ceiling (Y=maxHeight + h)
                        this.y = CFG.maxHeight + this.h;
                    }
                    this.dy = 0;
                    this.onGround = true; // Set onGround to true after the flip for immediate control
                    
                    AUDIO.gravity();
                    Game.level.splice(i, 1);
                }
                
                // Size Portals
                else if(o.t===9) { this.updateSize(CFG.MINI_SCALE); this.g = Math.abs(CFG.g * this.scale) * Math.sign(this.g); Game.level.splice(i, 1); }
                else if(o.t===10) { this.updateSize(CFG.MACRO_SCALE); this.g = Math.abs(CFG.g * this.scale) * Math.sign(this.g); Game.level.splice(i, 1); }

                // Solid Block Collision
                else if(o.t===1) { 
                    if(this.mode === 'wave') Game.crash(); 
                    if(isX) { Game.crash(); }
                    else {
                        let prevB = b - this.dy; 
                        let prevT = t - this.dy; 
                        let hitGround = false;

                        if (this.g > 0 && this.dy > 0 && prevB <= ot + 5) { this.y = ot; this.dy = 0; hitGround = true; } 
                        else if (this.g < 0 && this.dy < 0 && prevT >= ob - 5) { this.y = ob + this.h; this.dy = 0; hitGround = true; } 
                        else if (this.g > 0 && this.dy < 0 && prevT >= ob - 5) { this.y = ob + this.h; this.dy = 0; } 
                        else if (this.g < 0 && this.dy > 0 && prevB <= ot + 5) { this.y = ot; this.dy = 0; }
                        
                        if(hitGround && (this.mode === 'cube' || this.mode === 'robot' || this.mode === 'swing')) this.onGround = true;
                        
                        if(this.mode === 'swing' && this.isSwinging) { this.isSwinging = true; this.swingBlock = o; }
                    }
                }
            }
        }
    },
    
    dash: function() {
        if (this.mode === 'cube' && this.dashTargetX === 0) {
            this.dashTargetX = this.x + CFG.DASH_DIST * this.scale;
            this.dy = 0; 
            Game.dashActive = true;
            AUDIO.dash();
            Game.showTutorialMessage("DASH!", 500);
        }
    },

    jump: function(continuous=false) {
        const jumpForce = CFG.jmp * this.scale;
        
        // Double Tap for Dash
        const now = Date.now();
        if (this.mode === 'cube' && this.onGround && !continuous) {
            if (now - this.lastJumpTime < 350) { // Double tap detection (350ms window)
                this.dash();
                this.lastJumpTime = 0; // Reset last jump time
                return;
            }
            this.lastJumpTime = now;
        }

        let hitOrb = false;
        // Orb check logic is usually here, but removed for simplicity.

        if(hitOrb) return;
        
        if((this.mode === 'cube' && this.onGround) || (this.mode === 'robot' && this.onGround)) {
            this.dy = -jumpForce * (this.mode === 'robot' ? 1.5 : 1.0) * Math.sign(this.g);
            this.onGround = false;
            AUDIO.jump();
        } else if(this.mode === 'ufo' || this.mode === 'ship') {
            // UFO/Ship allows repeated press regardless of onGround, handled by update loop
            // The action only sets the "held" state for these modes.
        } else if(this.mode === 'swing') {
             // Swing logic (unchanged)
        }
    },

    setMode: function(m, force = false) {
        if(this.mode === m && !force) return;
        this.mode = m; 
        
        this.g = Math.abs(CFG.g * this.scale) * Math.sign(this.g); 
        this.isSwinging = false;
        this.swingBlock = null;

        if (m === 'cube' || m === 'robot' || m === 'swing') {
            this.dy = 0;
            this.onGround = true;
        }
        
        AUDIO.pad();
        const msg = document.getElementById('msg');
        let scaleText = this.scale < 1 ? ' (MINI)' : (this.scale > 1 ? ' (MACRO)' : '');
        msg.innerText = m.toUpperCase() + scaleText; 
        msg.style.opacity = 1;
        setTimeout(()=>msg.style.opacity=0, 1000);
    },

    draw: function(ctx, camY) {
        ctx.save();
        let drawY = this.y + camY; 
        
        const playerCenterX = this.x - Game.camX + this.w/2;
        const playerCenterY = drawY - this.h/2;

        ctx.translate(playerCenterX, playerCenterY);
        ctx.rotate(this.angle);

        let displayMain = this.mainColor;
        // Mode color definitions (unchanged)

        if(this.isSwinging) { /* Swing line logic */ }

        ctx.fillStyle = displayMain;

        const halfW = this.w / 2;
        const halfH = this.h / 2;
        
        if (this.mode === 'wave') { /* Wave drawing logic */ } 
        else {
            // General Cube/Robot/Ship/UFO/Swing drawing
            ctx.fillRect(-halfW,-halfH,this.w,this.h);
            
            ctx.fillStyle = this.secondaryColor; 
            ctx.fillRect(-halfW * 0.5, -halfH * 0.5, halfW, halfH); 
            ctx.fillStyle = '#fff'; 
            ctx.fillRect(-halfW * 0.25, -halfH * 0.25, halfW * 0.5, halfH * 0.5); 
        }
        
        ctx.restore();
    }
};

// --- UI (Redesigned with FIXES for responsiveness) ---
const UI = {
    hide: () => document.querySelectorAll('.ui-layer').forEach(e => e.classList.replace('visible','hidden')),
    
    // FIX: Re-implementing UI.show to make buttons visible
    show: (id) => { 
        UI.hide();
        document.getElementById(id).classList.replace('hidden', 'visible');
    },
    
    // FIX: Re-implementing UI.home to return to main menu
    home: () => { 
        Game.state = 'menu';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('unlock-count').innerText = unlocked;
        document.getElementById('menu-coins').innerText = totalCoins;
        Game.checkMobileControls();
        AUDIO.stopBGM();
        UI.show('menu-main');
    },
    
    // FIX: Re-implementing UI.startPlay to go to level select
    startPlay: () => { 
        UI.showLevels();
    },
    
    changeLevelPage: (direction) => {
        const maxPage = Math.ceil(CFG.TOTAL_LEVELS / CFG.LEVELS_PER_PAGE);
        currentPage = Math.min(maxPage, Math.max(1, currentPage + direction));
        UI.renderLevelGrid();
    },

    renderLevelGrid: () => {
        const grid = document.getElementById('lvl-grid');
        const prevBtn = document.getElementById('level-prev');
        const nextBtn = document.getElementById('level-next');

        grid.innerHTML = '';
        
        const start = (currentPage - 1) * CFG.LEVELS_PER_PAGE;
        const end = Math.min(CFG.TOTAL_LEVELS, start + CFG.LEVELS_PER_PAGE);

        // Grid must show 10 items (5x2), padding with hidden elements if necessary
        for(let i=start; i<start + CFG.LEVELS_PER_PAGE; i++) {
            let b = document.createElement('div');
            if (i < CFG.TOTAL_LEVELS) {
                b.innerText = i + 1; 
                if(i + 1 > unlocked) {
                    b.classList.add('locked');
                } else {
                    b.onclick = () => Game.loadLevel(i); 
                }
            } else {
                b.innerText = '';
                b.classList.add('locked'); // Empty slots are locked/disabled
                b.style.opacity = 0.2;
            }
            b.className = 'lvl-btn';
            grid.appendChild(b);
        }
        
        const maxPage = Math.ceil(CFG.TOTAL_LEVELS / CFG.LEVELS_PER_PAGE);
        prevBtn.disabled = currentPage <= 1;
        nextBtn.disabled = currentPage >= maxPage;
    },

    // FIX: Re-implementing UI.showLevels
    showLevels: () => {
        UI.renderLevelGrid();
        UI.show('menu-levels');
    },

    renderShop: function() {
        const shopContent = document.getElementById('shop-content');
        shopContent.innerHTML = '';

        SKINS.forEach((skin, index) => {
            const item = document.createElement('div');
            item.className = 'costume-item';

            const isUnlocked = unlockedSkins.includes(index);
            const isEquipped = equippedSkinIndex === index;

            if (isUnlocked) item.classList.add('unlocked');
            if (isEquipped) item.classList.add('equipped');

            const previewHTML = `
                <div class="costume-preview">
                    <div class="player-preview-cube" style="background-color:${skin.main}; border-color:${skin.secondary};">
                        <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:15px; height:15px; background-color:${skin.secondary};"></div>
                        <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:5px; height:5px; background-color:#fff;"></div>
                    </div>
                </div>
            `;
            
            item.innerHTML = `
                ${previewHTML}
                <strong>${skin.name}</strong><br>
                <div class="cost">${isUnlocked ? (isEquipped ? 'EQUIPPED' : 'Click to Equip') : `Cost: ${skin.cost} ðŸ’°`}</div>
            `;
            
            item.onclick = (e) => {
                e.stopPropagation(); 
                if (isUnlocked) {
                    Player.equipSkin(index);
                } else if (totalCoins >= skin.cost) {
                    totalCoins -= skin.cost;
                    unlockedSkins.push(index);
                    localStorage.setItem('nd_skins', JSON.stringify(unlockedSkins));
                    Game.updateCoinDisplay();
                    Player.equipSkin(index);
                } else {
                    alert(`Not enough coins! Requires ${skin.cost} ðŸ’°.`);
                }
            };

            shopContent.appendChild(item);
        });
    },

    // FIX: Re-implementing UI.showShop
    showShop: function() {
        UI.renderShop();
        UI.show('menu-shop');
    }
};

// --- INPUT (Fixed Spacebar hold reset bug and added continuous jump) ---
const Input = { 
    held: false, 
    mousePressed: false
};
const action = () => { 
    if(Game.state === 'game') {
        Input.held=true; 
        AUDIO.init(); 
        
        // Ship/UFO only need the held state. Cube/Robot/Swing need the discrete jump trigger.
        if (Player.mode !== 'ship' && Player.mode !== 'ufo') {
            Player.jump(); 
        }
    }
};
const release = () => { Input.held=false; };

const isUIElement = (target) => {
    return target.closest('.ui-layer') || target.closest('.mobile-btn') || target.tagName === 'BUTTON' || target.classList.contains('lvl-btn');
};

Input.touchStartAction = (e) => { 
    e.preventDefault(); 
    Input.mousePressed = true; 
    action(); 
};
Input.touchEndAction = (e) => { 
    e.preventDefault(); 
    Input.mousePressed = false; 
    release(); 
};

window.onkeydown = (e) => { 
    if(e.repeat) return; 
    
    if(e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault(); 
        action();
    }
    else if (e.code === 'KeyR') {
        Game.retry();
    }
    else if (e.code === 'Escape' && Game.state==='game') {
        UI.home();
    }
};

window.onkeyup = (e) => { 
    if(e.code === 'Space' || e.code === 'ArrowUp') {
        release();
    }
};

window.onmousedown = (e) => {
    if(!isUIElement(e.target) && Game.state === 'game') {
        Input.mousePressed = true;
        action();
    }
};

window.onmouseup = () => { 
    Input.mousePressed = false;
    release(); 
};

window.ontouchstart = (e) => {
    if (isUIElement(e.target)) return; 
    Input.mousePressed = true;
};

window.ontouchend = () => { 
    Input.mousePressed = false;
};

Game.init();
</script>
</body>
</html>
