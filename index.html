<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Dash V14.0: Hand-Crafted Levels & UI Fixes</title>
    <style>
        :root {
            --primary: #00f0ff;
            --secondary: #ff0055;
            --bg: #121212;
            --panel: rgba(15, 15, 25, 0.95);
            --font-main: 'Orbitron', sans-serif;
            --player-main: #00f0ff;
            --player-sec: #ff0055;
            --accent-green: #00ff00;
        }
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0; overflow: hidden; background-color: var(--bg);
            font-family: var(--font-main); color: white; user-select: none;
        }

        #game-container { position: relative; width: 100vw; height: 100vh; background: #000; }
        canvas { display: block; width: 100%; height: 100%; }

        /* UI LAYERS */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: 0.3s; z-index: 10;
        }
        .hidden { opacity: 0; pointer-events: none; transform: scale(1.1); }
        .visible { opacity: 1; pointer-events: auto; transform: scale(1); } 

        .menu-box {
            background: var(--panel); padding: 40px; border-radius: 12px;
            border: 2px solid var(--primary); 
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            text-align: center; min-width: 350px;
        }

        @keyframes pulse {
            0% { text-shadow: 0 0 5px var(--primary); }
            50% { text-shadow: 0 0 20px var(--primary), 0 0 30px rgba(0, 240, 255, 0.5); }
            100% { text-shadow: 0 0 5px var(--primary); }
        }

        h1 {
            font-size: 3.5rem; margin: 0 0 10px 0; text-transform: uppercase;
            background: linear-gradient(to bottom, #fff, var(--primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: pulse 2s infinite alternate;
        }

        button {
            background: linear-gradient(180deg, #333, #111);
            border: 1px solid #555; color: #fff;
            padding: 15px 30px; font-family: var(--font-main); font-size: 1.2rem;
            margin: 10px; cursor: pointer; text-transform: uppercase; font-weight: bold;
            box-shadow: 0 4px 0 #000; transition: transform 0.1s;
        }
        button:active { transform: translateY(4px); box-shadow: 0 0 0 #000; }
        button:hover { border-color: var(--primary); color: var(--primary); }
        
        button.secondary { background: linear-gradient(180deg, #311, #100); }
        button.secondary:hover { border-color: var(--secondary); color: var(--secondary); }
        
        button.next { background: linear-gradient(180deg, #0a0, #040); border-color: #0f0; }
        button.next:hover { color: #0f0; }

        /* Level Grid */
        .level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            padding: 20px;
            max-width: 500px;
        }
        .lvl-btn {
            background: #222;
            border: 2px solid #555;
            padding: 15px 10px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.1s;
        }
        .lvl-btn:not(.locked):hover { background: var(--primary); color: #000; border-color: #fff; }
        .lvl-btn.locked { background: #111; color: #555; border-style: dotted; cursor: not-allowed; }
        
        /* Level Paged Container */
        .level-paged-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .nav-arrow {
            padding: 10px;
            margin: 0 10px;
            font-size: 2rem;
            min-width: 50px;
        }
        .nav-arrow:disabled {
            opacity: 0.3;
            cursor: default;
        }

        /* Editor UI (unchanged) */
        #editor-overlay { pointer-events: auto !important; }
        #editor-ui {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #111; padding: 10px; border-radius: 10px; border: 1px solid #333;
            display: flex; gap: 5px; pointer-events: all;
            max-width: 95vw; overflow-x: auto;
        }
        .tool {
            min-width: 40px; height: 40px; border: 1px solid #444; cursor: pointer;
            display: flex; justify-content: center; align-items: center; font-size: 0.7rem; font-weight: bold;
        }
        .tool.active { background: var(--primary); color: black; border-color: white; }

        /* MOBILE CONTROLS (unchanged) */
        #mobile-controls {
            position: fixed; bottom: 0; left: 0; right: 0; height: 100vh;
            z-index: 5; display: none; 
            pointer-events: none; 
        }
        .mobile-btn {
            position: absolute; bottom: 0; height: 100%;
            background: rgba(255, 255, 255, 0.05); 
            transition: background 0.1s;
            display: flex; justify-content: center; align-items: center;
            pointer-events: auto; 
        }
        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.2);
        }
        #mobile-action {
            left: 0; width: 70%;
        }
        #mobile-reset {
            right: 0; width: 30%;
            font-size: 1.5rem;
            color: rgba(255, 0, 0, 0.7);
        }
        
        @media (max-width: 768px) {
            .show-mobile #mobile-controls {
                display: block;
            }
        }
        
        /* HUD (Reused) */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none;
        }
        .progress-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 60%; height: 10px; background: rgba(255,255,255,0.1); border: 1px solid #fff;
        }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; }

        /* Shop Styles (unchanged) */
        #shop-content {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .costume-item {
            padding: 15px;
            border: 2px solid #555;
            border-radius: 8px;
            cursor: pointer;
            width: 120px;
            text-align: center;
            transition: all 0.2s;
        }
        .costume-item:hover {
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.3);
        }
        .costume-item.equipped {
            border-color: var(--accent-green);
            background: rgba(0, 255, 0, 0.1);
        }
        .costume-preview {
            width: 50px;
            height: 50px;
            margin: 0 auto 10px;
            position: relative;
        }
        .player-preview-cube {
            width: 50px;
            height: 50px;
            border: 3px solid;
            position: relative;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="msg">MODE</div>
        <div id="tutorial-msg" style="display: none;"></div>

        <div id="hud">
            <div style="position: absolute; top:15px; left:20px; font-size:1.2rem;">ATTEMPT <span id="att">1</span></div>
            <div class="progress-bar"><div class="progress-fill" id="prog"></div></div>
            <div id="coin-count" style="position: absolute; top:15px; right:20px; font-size:1.2rem;">0</div>
        </div>
        
        <div id="mobile-controls">
            <div id="mobile-action" class="mobile-btn" 
                 ontouchstart="Input.touchStartAction(event)" 
                 ontouchend="Input.touchEndAction(event)"
            ></div>
            <div id="mobile-reset" class="mobile-btn" 
                 ontouchstart="Game.retry(event)" 
            >R</div>
        </div>

        <div id="menu-main" class="ui-layer visible">
            <div class="menu-box">
                <h1>NEON DASH</h1>
                <p style="letter-spacing:4px; color:#888; font-size:0.8rem; margin-top:-10px;">V14.0</p>
                <button onclick="UI.startPlay()">Play Levels</button>
                <button onclick="UI.showShop()">Shop</button>
                <button class="secondary" onclick="UI.showEditor()">Level Editor</button>
                
                <div style="margin-top:10px; font-size: 0.8rem; color:#666;">
                    Controls: **Space/â†‘** (Action), **R** (Reset)
                </div>
                <div style="margin-top:5px; font-size: 0.8rem; color:#666;">
                    Levels unlocked: <span id="unlock-count">1</span>/10 | Coins: <span id="menu-coins">0</span>
                </div>
            </div>
        </div>

        <div id="menu-levels" class="ui-layer hidden">
            <div class="menu-box">
                <h2>SELECT LEVEL</h2>
                <div class="level-paged-container">
                    <button id="level-prev" class="nav-arrow" onclick="UI.changeLevelPage(-1)" disabled>&#9664;</button>
                    <div class="level-grid" id="lvl-grid"></div>
                    <button id="level-next" class="nav-arrow" onclick="UI.changeLevelPage(1)" disabled>&#9654;</button>
                </div>
                <button class="secondary" onclick="Game.loadCustom()">CUSTOM</button>
                <br>
                <button onclick="UI.home()">BACK</button>
            </div>
        </div>

        <div id="menu-shop" class="ui-layer hidden">
            <div class="menu-box">
                <h2>CUBE SHOP</h2>
                <div style="font-size: 1.2rem;">Your Coins: <span id="shop-coins">0</span> ðŸ’°</div>
                <div id="shop-content"></div>
                <button onclick="UI.home()">BACK</button>
            </div>
        </div>

        <div id="menu-pause" class="ui-layer hidden">
            <div class="menu-box">
                <h1 id="pause-title" style="font-size: 2.5rem;">CRASHED</h1>
                <p id="pause-p">0%</p>
                <button id="pause-main-btn" onclick="Game.retry()">RETRY (R Key)</button>
                <button class="secondary" onclick="UI.home()">MENU</button>
            </div>
        </div>

        <div id="editor-overlay" class="ui-layer hidden">
            <div id="editor-ui">
                <div class="tool active" onclick="Editor.setTool(1)">BLK</div>
                <div class="tool" onclick="Editor.setTool(100)">SPAM</div>
                <div class="tool" onclick="Editor.setTool(2)">SPK</div>
                <div class="tool" onclick="Editor.setTool(7)">PAD</div>
                <div class="tool" onclick="Editor.setTool(3)">COI</div>
                <div class="tool" style="border-color:#0f0; color:#0f0;" onclick="Editor.setTool(4)">SHP</div>
                <div class="tool" style="border-color:#fa0; color:#fa0;" onclick="Editor.setTool(5)">UFO</div>
                <div class="tool" style="border-color:#0ff; color:#0ff;" onclick="Editor.setTool(6)">CUB</div>
                <div class="tool" style="border-color:#f50; color:#f50;" onclick="Editor.setTool(11)">WAVE</div>
                <div class="tool" style="border-color:#0f5; color:#0f5;" onclick="Editor.setTool(12)">ROBOT</div>
                <div class="tool" style="border-color:#fff; color:#fff; background:#55f;" onclick="Editor.setTool(8)">GRV</div>
                <div class="tool" style="border-color:#f80; color:#f80; background:#fff;" onclick="Editor.setTool(9)">MINI</div>
                <div class="tool" style="border-color:#08f; color:#08f; background:#000;" onclick="Editor.setTool(10)">MACR</div>
                <div class="tool" style="border-color:#fff; color:#fff; background:#0f0;" onclick="Editor.setTool(99)">GOAL</div>
                <div class="tool" style="border-color:#f55; color:#f55;" onclick="Editor.setTool(0)">DEL</div>
                <div style="min-width:10px"></div>
                <div class="tool secondary" onclick="Editor.test()">GO</div>
                <div class="tool secondary" onclick="Editor.save()">SAV</div>
                <div class="tool secondary" onclick="UI.home()">X</div>
            </div>
            <div style="position: absolute; top:20px; right:20px; text-align: right; pointer-events: all;">
                <p>Arrows: Camera | Click: Place</p>
            </div>
        </div>
    </div>

<script>
// --- CONFIGURATION ---
const CFG = {
    g: 0.8,       
    jmp: 15.0,    
    spd: 8.5,     
    term: 18,     
    tile: 50,
    MINI_SCALE: 0.6, 
    MACRO_SCALE: 1.0, 
    maxHeight: -250, 
    START_X: 35,
    PAD_JUMP: -25, 
    TOTAL_LEVELS: 10, // Changed to 10 hand-crafted levels
    LEVELS_PER_PAGE: 10, // All on one page now
    EDITOR_SPAM_RATE: 1, 
};

// --- GLOBAL STATE ---
let unlocked = parseInt(localStorage.getItem('nd_level') || 1);
let totalCoins = parseInt(localStorage.getItem('nd_coins') || 0);
let unlockedSkins = JSON.parse(localStorage.getItem('nd_skins') || '[0]');
let equippedSkinIndex = parseInt(localStorage.getItem('nd_equipped_skin') || 0);
let tutorialDone = localStorage.getItem('nd_tutorial_done') === 'true';
let currentPage = 1;

// --- THEME DATA (unchanged) ---
const THEMES = [
    // [BGM_FREQUENCY, BACKGROUND_HUE, BASE_HUE_SATURATION]
    [80, 200, 15],  
    [100, 120, 20], 
    [120, 60, 25],  
    [140, 0, 30],   
    [160, 270, 35], 
    [180, 330, 40], 
    [200, 180, 45], 
    [220, 240, 50], 
    [240, 0, 80]    
];

// --- SKINS/COSTUMES (unchanged) ---
const SKINS = [
    { name: "Default Neon", cost: 0, main: '#00f0ff', secondary: '#ff0055' },
    { name: "Fire Cube", cost: 10, main: '#ff0000', secondary: '#ffaa00' },
    { name: "Electric Purple", cost: 25, main: '#9d00ff', secondary: '#00ffaa' },
    { name: "Shadow Black", cost: 50, main: '#111111', secondary: '#ffffff' },
    { name: "Gold Plated", cost: 100, main: '#ffd700', secondary: '#aa5500' },
];

// --- AUDIO (unchanged) ---
const AUDIO = {
    ctx: null, bgmLoop: false, currentBGM: null, 
    init: function() { 
        if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)(); 
    },
    tone: function(f, t, d, v=0.1, s=0) { /* ... */
        if(!this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type=t; o.frequency.value=f; 
        if(s) o.frequency.linearRampToValueAtTime(s, this.ctx.currentTime+d);
        g.gain.setValueAtTime(v, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime+d);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime+d);
    },
    jump: () => AUDIO.tone(100, 'square', 0.1, 0.1),
    die: () => AUDIO.tone(80, 'sawtooth', 0.4, 0.2, 10),
    orb: () => AUDIO.tone(600, 'sine', 0.1, 0.1, 1200),
    pad: () => AUDIO.tone(300, 'square', 0.2, 0.1, 800),
    coin: () => AUDIO.tone(1000, 'sine', 0.05, 0.2, 1200),
    win: () => { AUDIO.tone(440,'triangle',0.1); setTimeout(()=>AUDIO.tone(554,'triangle',0.1),100); setTimeout(()=>AUDIO.tone(660,'triangle',0.4),200); },
    gravity: () => AUDIO.tone(500, 'sine', 0.1, 0.3, 200),
    
    startBGM: function(freq) { /* ... (BGM logic unchanged) ... */
        if (!this.ctx) return;

        this.currentBGM = { baseFreq: freq };
        if (this.bgmLoop) this.stopBGM(); 
        
        this.bgmLoop = true;
        
        const playSynth = (time, f, type, duration, gain) => {
            const osc = this.ctx.createOscillator();
            const gainNode = this.ctx.createGain();
            
            osc.type = type;
            osc.frequency.setValueAtTime(f, time);
            gainNode.gain.setValueAtTime(gain, time);
            
            osc.connect(gainNode);
            gainNode.connect(this.ctx.destination);
            
            osc.start(time);
            osc.stop(time + duration);
        };

        const sequence = (startTime, baseFreq) => {
            const f1 = baseFreq;
            const f2 = baseFreq * 1.25; 
            const f3 = baseFreq * 1.5;  
            const beat = 0.5; 
            let t = startTime;
            
            playSynth(t, f1, 'square', beat * 4, 0.05); 
            playSynth(t, f1 * 2, 'triangle', beat, 0.05);   
            playSynth(t + beat, f2 * 2, 'triangle', beat, 0.05);
            playSynth(t + beat * 2, f3 * 2, 'triangle', beat, 0.05);
            
            t += beat * 4;
            playSynth(t, f2, 'square', beat * 4, 0.05); 
            playSynth(t, f2 * 2, 'triangle', beat, 0.05);
            playSynth(t + beat, f3 * 2, 'triangle', beat, 0.05);
            playSynth(t + beat * 2, f1 * 2, 'triangle', beat, 0.05);

            return t + beat * 4; 
        };

        const loop = (t) => {
            if (!this.bgmLoop || !this.currentBGM) return;
            const nextT = sequence(t, this.currentBGM.baseFreq);
            setTimeout(() => loop(nextT), (nextT - t) * 1000);
        };
        
        loop(this.ctx.currentTime);
    },
    stopBGM: function() {
        this.bgmLoop = false;
        this.currentBGM = null;
    }
};

// --- HAND-CRAFTED LEVEL DATA (10 Levels) ---
// t: 1=Block, 2=Spike, 3=Coin (Orb), 4=Ship Portal, 5=UFO Portal, 6=Cube Portal, 7=Jump Pad, 8=Gravity Switch, 9=Mini, 10=Macro, 11=Wave Portal, 12=Robot Portal, 99=Goal
const LEVELS = [
    // 0. The Basics (Tutorial) - Cube, Jump Pad, Coin, Spike
    [{t:1,x:40,y:0},{t:1,x:41,y:0},{t:2,x:45,y:0},{t:3,x:48,y:2},{t:1,x:51,y:1},{t:7,x:55,y:0},{t:1,x:60,y:2},{t:2,x:62,y:0},{t:1,x:68,y:0},{t:99,x:80,y:0}],

    // 1. Ship Launch - Intro Ship mode
    [{t:1,x:40,y:0},{t:4,x:45,y:1},{t:1,x:60,y:4},{t:1,x:70,y:4},{t:1,x:80,y:4},{t:6,x:85,y:1},{t:99,x:100,y:0}],

    // 2. The Weight of Gravity - Cube, Gravity Switch, and Upside-down Spikes
    [{t:1,x:40,y:0},{t:2,x:45,y:0},{t:8,x:50,y:2},{t:2,x:55,y:4},{t:1,x:60,y:4},{t:8,x:65,y:2},{t:1,x:70,y:0},{t:99,x:90,y:0}],

    // 3. Mini Hurdles - Cube, Mini, and low spikes
    [{t:1,x:40,y:0},{t:9,x:45,y:1},{t:2,x:50,y:0},{t:1,x:55,y:0},{t:2,x:56,y:0},{t:1,x:60,y:0},{t:10,x:65,y:1},{t:99,x:85,y:0}],

    // 4. UFO Floater - UFO mode with high and low blocks
    [{t:1,x:40,y:0},{t:5,x:45,y:2},{t:1,x:55,y:0},{t:1,x:60,y:3},{t:1,x:65,y:0},{t:1,x:70,y:4},{t:6,x:75,y:2},{t:99,x:100,y:0}],

    // 5. Robot Leap - Robot mode and timing the large jump
    [{t:1,x:40,y:0},{t:12,x:45,y:0},{t:1,x:50,y:0},{t:2,x:52,y:0},{t:1,x:55,y:0},{t:2,x:60,y:0},{t:1,x:65,y:0},{t:1,x:75,y:0},{t:1,x:85,y:0},{t:6,x:90,y:0},{t:99,x:110,y:0}],

    // 6. Wave Tunnel - Intro Wave mode, requires holding/releasing
    [{t:1,x:40,y:0},{t:11,x:45,y:0},{t:1,x:50,y:3},{t:1,x:55,y:1},{t:1,x:60,y:4},{t:1,x:65,y:1},{t:1,x:70,y:3},{t:6,x:75,y:0},{t:99,x:100,y:0}],

    // 7. Mini Ship Maze - Mini and Ship mode, tight corridor
    [{t:1,x:40,y:0},{t:9,x:42,y:1},{t:4,x:45,y:1},{t:1,x:50,y:3},{t:1,x:55,y:3},{t:1,x:60,y:3},{t:1,x:65,y:3},{t:6,x:70,y:1},{t:10,x:73,y:1},{t:99,x:95,y:0}],

    // 8. Gravity Flips and UFO - Gravity switches during UFO
    [{t:1,x:40,y:0},{t:5,x:45,y:2},{t:8,x:55,y:2},{t:1,x:65,y:4},{t:8,x:75,y:2},{t:1,x:85,y:0},{t:6,x:90,y:0},{t:99,x:120,y:0}],
    
    // 9. Everything Gauntlet - Combining Mini Robot, Wave, and Ship in quick succession
    [{t:1,x:40,y:0},{t:12,x:45,y:0},{t:9,x:47,y:0},{t:1,x:50,y:0},{t:11,x:55,y:0},{t:1,x:60,y:2},{t:4,x:65,y:2},{t:1,x:75,y:4},{t:6,x:80,y:0},{t:10,x:82,y:0},{t:99,x:110,y:0}],
];


// --- ENGINE (No functional changes) ---
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    state: 'menu', 
    level: [], 
    att: 1, 
    camX: 0, 
    floorY: 0,
    shake: 0,
    currLvlIdx: 0,
    pauseBtn: document.getElementById('pause-main-btn'),
    bgHue: 200, 
    bgSat: 15,  
    isMobile: window.innerWidth <= 768, 

    init: function() {
        this.resize();
        window.onresize = ()=>this.resize();
        document.getElementById('unlock-count').innerText = unlocked;
        document.getElementById('unlock-count').parentElement.innerHTML = `Levels unlocked: <span id="unlock-count">${unlocked}</span>/${CFG.TOTAL_LEVELS}`;
        Player.loadColors();
        this.updateCoinDisplay();
        AUDIO.init();
        this.checkMobileControls();
        this.loop();
    },
    updateCoinDisplay: function() {
        document.getElementById('coin-count').innerText = totalCoins;
        if(document.getElementById('menu-coins')) document.getElementById('menu-coins').innerText = totalCoins;
        if(document.getElementById('shop-coins')) document.getElementById('shop-coins').innerText = totalCoins;
        localStorage.setItem('nd_coins', totalCoins);
    },
    resize: function() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.floorY = this.canvas.height - 150;
        this.isMobile = window.innerWidth <= 768;
        this.checkMobileControls();
    },
    checkMobileControls: function() {
        if (this.isMobile && this.state === 'game') {
            document.getElementById('game-container').classList.add('show-mobile');
        } else {
            document.getElementById('game-container').classList.remove('show-mobile');
        }
    },
    loadLevel: function(idx) {
        if(idx < 0 || idx >= LEVELS.length) return;
        this.currLvlIdx = idx;
        
        // Theme selection based on level index (Cycles through themes)
        const themeIdx = idx % THEMES.length; 
        const theme = THEMES[themeIdx];
        this.bgHue = theme[1];
        this.bgSat = theme[2];
        
        this.level = JSON.parse(JSON.stringify(LEVELS[idx]));
        this.start(theme[0]); 
    },
    loadCustom: function() {
        let d = localStorage.getItem('nd_custom');
        if(!d) return alert("No Saved Level!");
        this.currLvlIdx = -1;
        this.level = JSON.parse(d);
        this.bgHue = 240; 
        this.bgSat = 10;
        this.start(150); 
    },
    start: function(bgmFreq) {
        this.state = 'game';
        Player.reset();
        this.camX = 0;
        this.att = 1; 
        document.getElementById('att').innerText = this.att;
        UI.hide();
        document.getElementById('hud').style.display = 'block';
        AUDIO.startBGM(bgmFreq);
        this.checkMobileControls(); 

        if(this.currLvlIdx === 0 && !tutorialDone) { 
            this.showTutorialMessage("Press ACTION to JUMP!", 5000);
            setTimeout(() => {
                if(this.state === 'game') this.showTutorialMessage("Collect the coin!", 5000);
            }, 6000);
        }
    },
    showTutorialMessage: function(message, duration) {
        const msgEl = document.getElementById('tutorial-msg');
        msgEl.innerText = message;
        msgEl.style.display = 'block';
        if (duration) {
            setTimeout(() => {
                if(msgEl.innerText === message) msgEl.style.display = 'none';
            }, duration);
        }
    },
    retry: function(e) { 
        if(e) e.preventDefault(); 
        if (this.state === 'game' || this.state === 'dead' || this.state === 'win') {
            this.state = 'game';
            Player.reset(); 
            this.att++;
            document.getElementById('att').innerText = this.att;
            UI.hide();
            document.getElementById('tutorial-msg').style.display = 'none';
            this.checkMobileControls(); 
        }
    },
    win: function() {
        this.state = 'win';
        AUDIO.win();
        AUDIO.stopBGM();
        document.getElementById('tutorial-msg').style.display = 'none';
        document.getElementById('pause-title').innerText = "COMPLETE!";
        document.getElementById('pause-p').innerText = "100%";
        
        let nextLvl = this.currLvlIdx + 1; 
        
        if (this.currLvlIdx === 0 && !tutorialDone) {
            tutorialDone = true;
            localStorage.setItem('nd_tutorial_done', 'true');
            nextLvl = 1;
        }

        if(this.currLvlIdx !== -1 && nextLvl < CFG.TOTAL_LEVELS) {
            if (nextLvl + 1 > unlocked) {
                unlocked = nextLvl + 1; 
                localStorage.setItem('nd_level', unlocked);
                document.getElementById('unlock-count').innerText = unlocked;
            }
            this.pauseBtn.innerText = "NEXT LEVEL (" + (nextLvl + 1) + ")";
            this.pauseBtn.className = "next";
            this.pauseBtn.onclick = () => Game.loadLevel(nextLvl);
        } else {
            this.pauseBtn.innerText = "MENU";
            this.pauseBtn.className = "secondary";
            this.pauseBtn.onclick = () => UI.home();
        }

        UI.show('menu-pause');
        this.checkMobileControls(); 
    },
    crash: function() {
        if(this.state !== 'game') return;
        this.state = 'dead';
        AUDIO.die();
        AUDIO.stopBGM();
        this.shake = 20;
        
        document.getElementById('tutorial-msg').style.display = 'none';

        let end = this.level.find(o=>o.t===99);
        let endX = end ? end.x * CFG.tile : (this.currLvlIdx === -1 ? 10000 : 5000); // Handle custom levels without goals
        
        let pct = Math.floor((Player.x / endX)*100);
        pct = Math.max(0, Math.min(99, pct)); // Cap at 99%

        setTimeout(() => {
            document.getElementById('pause-title').innerText = "CRASHED";
            document.getElementById('pause-p').innerText = pct + "%";
            this.pauseBtn.innerText = "RETRY (R Key)";
            this.pauseBtn.className = "";
            this.pauseBtn.onclick = () => Game.retry();
            UI.show('menu-pause');
            this.checkMobileControls(); 
        }, 800);
    },
    
    loop: function() {
        let ctx = this.ctx;
        
        // Dynamic Background Color 
        let hue = this.bgHue;
        if (this.bgSat > 30) hue = (this.bgHue + (Player.x / 20) % 360) % 360; 
        
        ctx.fillStyle = `hsl(${hue}, ${this.bgSat}%, 10%)`;
        ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
        
        ctx.save();
        if(this.shake>0) {
            ctx.translate((Math.random()-.5)*this.shake, (Math.random()-.5)*this.shake);
            this.shake*=0.9;
        }
        
        if(Player.g < 0) {
            ctx.scale(1, -1);
            ctx.translate(0, -this.canvas.height); 
        }

        // Physics
        if(this.state === 'game') {
            Player.update();
            this.camX = Player.x - 300;
        } 

        // Camera Y 
        let targetY = Player.y * 0.6;
        let camY = (this.canvas.height - 150) - targetY; 
        
        // Draw Grid and Floor 
        ctx.strokeStyle = `hsla(${hue}, 50%, 50%, 0.1)`;
        ctx.lineWidth = 2;
        let ox = -(this.camX % CFG.tile);
        for(let i=ox; i<this.canvas.width; i+=CFG.tile) {
            ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i-100, this.canvas.height); ctx.stroke();
        }
        ctx.fillStyle = Player.mainColor;
        ctx.fillRect(0, camY, this.canvas.width, 2);
        ctx.fillStyle = '#111';
        ctx.fillRect(0, camY+2, this.canvas.width, 500);

        // Draw Objects (Rendering logic unchanged)
        this.level.forEach(o => {
            let dx = o.x * CFG.tile - this.camX;
            let dy = camY - (o.y * CFG.tile) - CFG.tile;
            if(dx < -CFG.tile || dx > this.canvas.width) return;

            if(o.t===1) { // Block
                ctx.fillStyle = `hsl(${hue}, 80%, 50%)`; ctx.fillRect(dx,dy,CFG.tile,CFG.tile);
                ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.strokeRect(dx,dy,CFG.tile,CFG.tile);
                ctx.fillStyle='rgba(0,0,0,0.4)'; ctx.fillRect(dx+5,dy+5,CFG.tile-10,CFG.tile-10);
            } 
            else if (o.t===2) { // Spike
                ctx.fillStyle='#f22'; ctx.beginPath();
                if (Player.g < 0 && Game.state === 'game') { 
                    ctx.moveTo(dx+10, dy); ctx.lineTo(dx+25, dy+45); ctx.lineTo(dx+40, dy);
                } else {
                    ctx.moveTo(dx+10, dy+CFG.tile); ctx.lineTo(dx+25, dy+5); ctx.lineTo(dx+40, dy+CFG.tile);
                }
                ctx.fill(); ctx.strokeStyle='#fff'; ctx.stroke();
            }
            else if (o.t===3) { // Coin (Orb)
                ctx.fillStyle='#ff0'; ctx.beginPath(); ctx.arc(dx+25,dy+25,12,0,7); ctx.fill();
                ctx.strokeStyle='#ff0'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(dx+25,dy+25,20,0,7); ctx.stroke();
            }
            else if (o.t===7) { // Pad
                ctx.fillStyle='#ff0'; ctx.fillRect(dx+5, dy+40, 40, 10);
                ctx.strokeStyle='#fff'; ctx.strokeRect(dx+5, dy+40, 40, 10);
            }
            else if (o.t===8) { // Gravity Switch
                ctx.fillStyle='#55f'; ctx.fillRect(dx, dy, CFG.tile, CFG.tile);
                ctx.fillStyle='#fff'; ctx.font='30px Orbitron'; ctx.textAlign='center';
                ctx.fillText(Player.g > 0 ? 'â†“' : 'â†‘', dx+25, dy+35);
            }
            else if (o.t===9) { // Mini Portal (Orange)
                ctx.fillStyle='#f80'; ctx.globalAlpha=0.3; ctx.fillRect(dx, dy+15, CFG.tile, 20); ctx.globalAlpha=1;
                ctx.strokeStyle='#f80'; ctx.lineWidth=2; ctx.strokeRect(dx+10, dy+10, 30, 30);
            }
            else if (o.t===10) { // Macro Portal (Blue)
                ctx.fillStyle='#08f'; ctx.globalAlpha=0.3; ctx.fillRect(dx, dy+15, CFG.tile, 20); ctx.globalAlpha=1;
                ctx.strokeStyle='#08f'; ctx.lineWidth=2; ctx.strokeRect(dx+5, dy+5, 40, 40);
            }
            else if (o.t===11) { // Wave Portal (Red)
                ctx.strokeStyle='#f55'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100);
            }
            else if (o.t===12) { // Robot Portal (Green)
                ctx.strokeStyle='#0f5'; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100);
            }
            else if (o.t===99) { // Goal
                ctx.fillStyle='#0f0'; ctx.globalAlpha=0.3; ctx.fillRect(dx, -500, 100, 2000); ctx.globalAlpha=1;
            }
            else { // Mode Portals
                let c = o.t===4?'#0f0':(o.t===5?'#fa0':(o.t===6?'#0ff':'#fff'));
                ctx.strokeStyle=c; ctx.lineWidth=4; ctx.strokeRect(dx,dy,40,100);
            }
        });

        // Player
        if(this.state !== 'editor' && this.state !== 'dead') Player.draw(ctx, camY);

        // Progress Bar
        if(this.state === 'game') {
            let end = this.level.find(o=>o.t===99);
            if(end) {
                let p = Math.max(0, Math.min(100, ((Player.x - CFG.START_X * CFG.tile) / ((end.x - CFG.START_X) * CFG.tile)) * 100));
                document.getElementById('prog').style.width = p+'%';
            }
        }

        ctx.restore();
        requestAnimationFrame(()=>this.loop());
    }
};

// --- PLAYER PHYSICS (unchanged) ---
const Player = {
    x:0, y:0, w:40, h:40, 
    dx: CFG.spd, dy:0, 
    mode:'cube', angle:0, onGround:false,
    g: CFG.g,
    scale: CFG.MACRO_SCALE, 
    mainColor: '#00f0ff',
    secondaryColor: '#ff0055',
    waveAngle: 0, 

    loadColors: function() {
        const skin = SKINS[equippedSkinIndex];
        this.mainColor = skin.main;
        this.secondaryColor = skin.secondary;
        document.documentElement.style.setProperty('--player-main', this.mainColor);
        document.documentElement.style.setProperty('--player-sec', this.secondaryColor);
    },
    equipSkin: function(index) {
        equippedSkinIndex = index;
        localStorage.setItem('nd_equipped_skin', index);
        this.loadColors();
        UI.renderShop();
    },

    reset: function() {
        this.x = CFG.START_X * CFG.tile; 
        this.y=0; this.dy=0; this.angle=0; 
        this.mode='cube'; this.onGround=true;
        this.g = CFG.g; 
        this.scale = CFG.MACRO_SCALE; 
        this.w = 40 * this.scale; 
        this.h = 40 * this.scale;
        this.waveAngle = 0;
    },

    updateSize: function(newScale) {
        if(this.scale === newScale) return;
        
        let oldH = this.h;
        this.scale = newScale;
        this.w = 40 * this.scale;
        this.h = 40 * this.scale;

        if (this.g > 0) { 
            this.y = this.y + (oldH - this.h); 
        } else { 
            this.y = this.y - (oldH - this.h); 
        }

        this.g = (CFG.g * newScale) * Math.sign(this.g);
    },

    update: function() {
        const gravityFactor = this.scale * (this.g > 0 ? 1 : -1);
        const termScaled = CFG.term * this.scale;
        
        if(this.mode === 'cube') {
            this.dy += CFG.g * gravityFactor;
            if(this.onGround) {
                let r = Math.round(this.angle/(Math.PI/2))*(Math.PI/2);
                this.angle += (r-this.angle)*0.25; 
            } else {
                this.angle += 0.18 * Math.sign(this.g);
            }
        } 
        else if (this.mode === 'ship') {
            if(Input.held) this.dy -= 0.6 * gravityFactor; 
            else this.dy += 0.5 * gravityFactor; 
            this.angle = this.dy * 0.15;
        } 
        else if (this.mode === 'ufo') {
            if(Input.held) this.dy -= 0.7 * gravityFactor;
            this.dy += CFG.g * gravityFactor;
            this.angle += (0-this.angle)*0.1;
        }
        else if (this.mode === 'wave') {
            if(Input.held) this.waveAngle = 45 * Math.sign(this.g);
            else this.waveAngle = -45 * Math.sign(this.g);
            
            const waveSpeed = 8 * this.scale;
            const waveRad = this.waveAngle * (Math.PI / 180);
            this.dy = Math.sin(waveRad) * -waveSpeed; 
            
            this.angle = waveRad * 1.5;
            this.dy += this.g * 0.0001; 
        }
        else if (this.mode === 'robot') {
            this.dy += CFG.g * gravityFactor;
            this.angle += (0-this.angle)*0.1; 
        }

        if (this.mode !== 'wave') {
            if(this.dy > termScaled) this.dy = termScaled;
            if(this.dy < -termScaled) this.dy = -termScaled;
        }

        this.x += this.dx;
        this.checkCol(true);

        this.y += this.dy;
        this.onGround = false;

        const floorHeight = 0;
        const ceilingHeight = CFG.maxHeight;

        if(this.g > 0) { // Normal Gravity
            if(this.y > floorHeight) { this.y = floorHeight; this.dy = 0; this.onGround = true; }
            if(this.y - this.h < ceilingHeight) { this.y = ceilingHeight + this.h; this.dy = 0; } 
        } else { // Reversed Gravity
            if(this.y - this.h < ceilingHeight) { this.y = ceilingHeight + this.h; this.dy = 0; this.onGround = true; }
            if(this.y > floorHeight) { this.y = floorHeight; this.dy = 0; }
        }
        
        if (this.mode === 'wave') {
            if(this.g > 0 && (this.y > floorHeight+1 || this.y - this.h < ceilingHeight-1)) Game.crash();
            if(this.g < 0 && (this.y - this.h < ceilingHeight-1 || this.y > floorHeight+1)) Game.crash();
        }

        this.checkCol(false);
    },

    checkCol: function(isX) {
        let l=this.x, r=this.x+this.w, t=this.y-this.h, b=this.y;
        
        for (let i = Game.level.length - 1; i >= 0; i--) {
            const o = Game.level[i];
            
            if(Math.abs(o.x*CFG.tile - this.x) > 100) continue; 

            let ox = o.x*CFG.tile, oy = -(o.y*CFG.tile);
            let ol = ox, or = ox+CFG.tile, ot = oy-CFG.tile, ob = oy;

            if(r>ol && l<or && b>ot && t<ob) {
                
                if(o.t===2) Game.crash();
                else if(o.t===99) { Game.win(); return; }
                else if(o.t===3) { 
                    totalCoins++;
                    AUDIO.coin();
                    Game.updateCoinDisplay();
                    Game.level.splice(i, 1);
                }
                else if(o.t===7 && Math.sign(this.dy) === Math.sign(this.g)) { 
                     this.dy = (-CFG.PAD_JUMP * this.scale) * Math.sign(this.g) * -1; 
                     this.onGround=false; 
                     AUDIO.pad();
                }
                else if(o.t===4) this.setMode('ship');
                else if(o.t===5) this.setMode('ufo');
                else if(o.t===6) this.setMode('cube');
                else if(o.t===11) this.setMode('wave');
                else if(o.t===12) this.setMode('robot');
                else if(o.t===8) { 
                    this.g *= -1;
                    this.g = Math.abs(CFG.g * this.scale) * Math.sign(this.g); 
                    AUDIO.gravity();
                    Game.level.splice(i, 1);
                }
                else if(o.t===9) { 
                    this.updateSize(CFG.MINI_SCALE);
                    this.setMode(this.mode);
                    Game.level.splice(i, 1);
                }
                else if(o.t===10) { 
                    this.updateSize(CFG.MACRO_SCALE);
                    this.setMode(this.mode);
                    Game.level.splice(i, 1);
                }
                else if(o.t===1) { // Block (Solid Fix)
                    if(this.mode === 'wave') Game.crash(); 
                    if(isX) { Game.crash(); }
                    else {
                        let prevB = b - this.dy; 
                        let prevT = t - this.dy; 
                        let hitGround = false;

                        if (this.g > 0 && this.dy > 0 && prevB <= ot + 5) { // Landing on top (Normal Gravity)
                            this.y = ot; this.dy = 0; hitGround = true;
                        } else if (this.g < 0 && this.dy < 0 && prevT >= ob - 5) { // Landing on bottom (Reversed Gravity)
                            this.y = ob + this.h; this.dy = 0; hitGround = true;
                        } else if (this.g > 0 && this.dy < 0 && prevT >= ob - 5) { // Hitting ceiling (Normal Gravity)
                            this.y = ob + this.h; this.dy = 0;
                        } else if (this.g < 0 && this.dy > 0 && prevB <= ot + 5) { // Hitting floor (Reversed Gravity ceiling)
                            this.y = ot; this.dy = 0;
                        }
                        
                        if((hitGround && this.mode === 'cube') || this.mode === 'robot') this.onGround = true;
                    }
                }
            }
        }
    },

    jump: function() {
        const jumpForce = CFG.jmp * this.scale;

        // Orb Check
        let hitOrb = false;
        let l=this.x, r=this.x+this.w, t=this.y-this.h, b=this.y;
        Game.level.forEach(o => {
            if(o.t===3) {
                let ox=o.x*CFG.tile, oy=-(o.y*CFG.tile)-CFG.tile;
                if(r>ox-20 && l<ox+70 && b>oy-20 && t<oy+70) {
                    this.dy = -jumpForce * 0.9 * Math.sign(this.g);
                    this.onGround = false;
                    hitOrb=true;
                    AUDIO.orb();
                }
            }
        });
        if(hitOrb) return;
        
        // Mode Jumps
        if(this.mode === 'cube' && this.onGround) {
            this.dy = -jumpForce * Math.sign(this.g);
            this.onGround = false;
            AUDIO.jump();
        } else if(this.mode === 'ufo') {
            this.dy = -jumpForce * 0.7 * Math.sign(this.g);
            AUDIO.jump();
        } else if(this.mode === 'robot' && this.onGround) {
            this.dy = -jumpForce * 1.5 * Math.sign(this.g); 
            this.onGround = false;
            AUDIO.jump();
        }
    },

    setMode: function(m) {
        if(this.mode === m) return;
        this.mode = m; 
        
        this.g = Math.abs(CFG.g * this.scale) * Math.sign(this.g); 

        if (m === 'cube' || m === 'robot') {
            this.dy = 0;
            this.onGround = true;
        }
        
        AUDIO.pad();
        const msg = document.getElementById('msg');
        let scaleText = this.scale < 1 ? ' (MINI)' : (this.scale > 1 ? ' (MACRO)' : '');
        msg.innerText = m.toUpperCase() + scaleText; 
        msg.style.opacity = 0.5;
        setTimeout(()=>msg.style.opacity=0, 1000);
    },

    draw: function(ctx, camY) {
        ctx.save();
        let drawY = this.y + camY; 
        
        const playerCenterX = this.x - Game.camX + this.w/2;
        const playerCenterY = drawY - this.h/2;

        ctx.translate(playerCenterX, playerCenterY);
        ctx.rotate(this.angle);

        let displayMain = this.mainColor;
        if(this.mode === 'ship') displayMain = '#0f0';
        if(this.mode === 'ufo') displayMain = '#fa0';
        if(this.mode === 'wave') displayMain = '#f55';
        if(this.mode === 'robot') displayMain = '#0f5';
        
        ctx.fillStyle = displayMain;

        const halfW = this.w / 2;
        const halfH = this.h / 2;
        
        if (this.mode === 'wave') {
            // Draw diamond/triangle shape for wave
            ctx.beginPath();
            ctx.moveTo(-halfW, 0);
            ctx.lineTo(0, -halfH);
            ctx.lineTo(halfW, 0);
            ctx.lineTo(0, halfH);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = this.secondaryColor;
            ctx.lineWidth = 4 * this.scale;
            ctx.stroke();
        } else {
            // Draw cube/ship/ufo/robot scaled
            ctx.fillRect(-halfW,-halfH,this.w,this.h);
            
            ctx.fillStyle = this.secondaryColor; 
            ctx.fillRect(-halfW * 0.5, -halfH * 0.5, halfW, halfH); 
            ctx.fillStyle = '#fff'; 
            ctx.fillRect(-halfW * 0.25, -halfH * 0.25, halfW * 0.5, halfH * 0.5); 
        }
        
        ctx.restore();
    }
};

// --- UI (Level Grid Updated) ---
const UI = {
    hide: () => document.querySelectorAll('.ui-layer').forEach(e => e.classList.replace('visible','hidden')),
    show: (id) => { 
        UI.hide();
        document.getElementById(id).classList.replace('hidden','visible');
        if (id === 'menu-shop') UI.renderShop();
        if (id === 'menu-main') AUDIO.stopBGM();
        Game.updateCoinDisplay();
        Game.checkMobileControls(); 
    },
    home: () => { 
        Game.state='menu'; 
        UI.show('menu-main'); 
        document.getElementById('hud').style.display='none'; 
        Game.checkMobileControls(); 
    },
    
    startPlay: () => {
        if (!tutorialDone) {
            Game.loadLevel(0);
        } else {
            UI.showLevels();
        }
    },
    
    changeLevelPage: (direction) => {
        // With only 10 levels, we don't need paging, but keeping the structure for future expansion.
        const maxPage = Math.ceil(CFG.TOTAL_LEVELS / CFG.LEVELS_PER_PAGE);
        currentPage = Math.min(maxPage, Math.max(1, currentPage + direction));
        UI.renderLevelGrid();
    },

    renderLevelGrid: () => {
        const grid = document.getElementById('lvl-grid');
        const prevBtn = document.getElementById('level-prev');
        const nextBtn = document.getElementById('level-next');

        grid.innerHTML = '';
        
        const start = (currentPage - 1) * CFG.LEVELS_PER_PAGE;
        const end = Math.min(CFG.TOTAL_LEVELS, start + CFG.LEVELS_PER_PAGE);

        for(let i=start; i<end; i++) {
            let b = document.createElement('div');
            b.className = 'lvl-btn';
            b.innerText = i + 1; // Display Level 1-10
            if(i + 1 > unlocked) {
                b.classList.add('locked');
            } else {
                b.onclick = () => Game.loadLevel(i); // Load by zero-based index (0-9)
            }
            grid.appendChild(b);
        }
        
        // Disable navigation controls as all 10 levels fit on one page
        prevBtn.disabled = true;
        nextBtn.disabled = true;
    },

    showLevels: () => {
        UI.renderLevelGrid();
        UI.show('menu-levels');
    },

    showEditor: () => { 
        Game.state = 'editor';
        Game.level = [];
        Game.camX = 0;
        document.getElementById('editor-overlay').classList.replace('hidden', 'visible');
        let d = localStorage.getItem('nd_custom');
        if(d) Game.level = JSON.parse(d);
        Editor.setTool(Editor.tool);
    },

    renderShop: function() {
        const shopContent = document.getElementById('shop-content');
        shopContent.innerHTML = '';

        SKINS.forEach((skin, index) => {
            const item = document.createElement('div');
            item.className = 'costume-item';

            const isUnlocked = unlockedSkins.includes(index);
            const isEquipped = equippedSkinIndex === index;

            if (isUnlocked) item.classList.add('unlocked');
            if (isEquipped) item.classList.add('equipped');

            const previewHTML = `
                <div class="costume-preview">
                    <div class="player-preview-cube" style="background-color:${skin.main}; border-color:${skin.secondary};">
                        <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:15px; height:15px; background-color:${skin.secondary};"></div>
                        <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:5px; height:5px; background-color:#fff;"></div>
                    </div>
                </div>
            `;
            
            item.innerHTML = `
                ${previewHTML}
                <strong>${skin.name}</strong><br>
                <div class="cost">${isUnlocked ? (isEquipped ? 'EQUIPPED' : 'Click to Equip') : `Cost: ${skin.cost} ðŸ’°`}</div>
            `;
            
            item.onclick = (e) => {
                e.stopPropagation(); 
                if (isUnlocked) {
                    Player.equipSkin(index);
                } else if (totalCoins >= skin.cost) {
                    totalCoins -= skin.cost;
                    unlockedSkins.push(index);
                    localStorage.setItem('nd_skins', JSON.stringify(unlockedSkins));
                    Game.updateCoinDisplay();
                    Player.equipSkin(index);
                } else {
                    alert(`Not enough coins! Requires ${skin.cost} ðŸ’°.`);
                }
            };

            shopContent.appendChild(item);
        });
    },

    showShop: function() {
        UI.show('menu-shop');
    }
};

// --- EDITOR (unchanged) ---
const Editor = {
    tool: 1,
    lastX: -1,
    lastY: -1,
    setTool: function(t) {
        this.tool = t;
        document.querySelectorAll('#editor-ui .tool').forEach(el => el.classList.remove('active'));
        const toolButtons = document.querySelectorAll('#editor-ui .tool');
        toolButtons.forEach(btn => {
            // Find the button by its label and activate
            const toolLabels = {1:'BLK', 100:'SPAM', 2:'SPK', 7:'PAD', 3:'COI', 4:'SHP', 5:'UFO', 6:'CUB', 11:'WAVE', 12:'ROBOT', 8:'GRV', 9:'MINI', 10:'MACR', 99:'GOAL', 0:'DEL'};
            if (btn.innerText === toolLabels[t]) btn.classList.add('active');
        });
    },
    placeBlock: function(gx, gy, tool) {
        if (gy < 0) return;
        
        Game.level = Game.level.filter(o=>!(o.x===gx && o.y===gy));
        
        if(tool !== 0 && tool !== 100) {
            Game.level.push({t:tool, x:gx, y:gy});
        }
        else if (tool === 100) { 
             Game.level.push({t:1, x:gx, y:gy});
        }
    },
    test: function() { localStorage.setItem('nd_custom', JSON.stringify(Game.level)); Game.loadCustom(); },
    save: function() { localStorage.setItem('nd_custom', JSON.stringify(Game.level)); alert('Saved!'); },
};

// --- INPUT (Crucial Fixes for UI Buttons) ---
const Input = { held: false, mousePressed: false };
const action = () => { Input.held=true; AUDIO.init(); if(Game.state==='game') Player.jump(); };
const release = () => { Input.held=false; };

// Helper to check if the event target is inside a UI element
const isUIElement = (target) => {
    return target.closest('.ui-layer') || target.closest('.mobile-btn') || target.closest('#editor-ui');
};

// Mobile/Touch Handlers 
Input.touchStartAction = (e) => { 
    e.preventDefault(); // Only prevent default on the dedicated action button
    Input.mousePressed = true; 
    action(); 
};
Input.touchEndAction = (e) => { 
    e.preventDefault(); // Only prevent default on the dedicated action button
    Input.mousePressed = false; 
    release(); 
};

// --- Keyboard Events (Unchanged) ---
window.onkeydown = (e) => { 
    if(e.repeat) return; 
    
    if(e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault(); 
        action();
    }
    else if (e.code === 'KeyR') {
        Game.retry();
    }
    else if (e.code === 'Escape' && Game.state==='game') {
        UI.home();
    }
};

window.onkeyup = (e) => { 
    if(e.code === 'Space' || e.code === 'ArrowUp') {
        release();
    }
};

// --- Mouse Events (FIXED) ---
window.onmousedown = (e) => {
    // If we click *outside* of the UI/Editor, treat it as a game action/placement
    if(!isUIElement(e.target)) {
        Input.mousePressed = true;

        if(Game.state === 'editor') {
            let mx = e.clientX + Game.camX;
            let gy = Math.floor(-(e.clientY - (Game.canvas.height - 150))/CFG.tile); 
            let gx = Math.floor(mx/CFG.tile);
            
            Editor.placeBlock(gx, gy, Editor.tool);
            Editor.lastX = gx;
            Editor.lastY = gy;
        } else {
            action();
        }
    }
    // IMPORTANT: Do NOT call preventDefault() here if it's a UI element click. 
    // This allows the default 'button' click handler to fire.
};

window.onmousemove = (e) => {
    if(Game.state === 'editor' && Input.mousePressed && Editor.tool === 100) {
        let mx = e.clientX + Game.camX;
        let gy = Math.floor(-(e.clientY - (Game.canvas.height - 150))/CFG.tile); 
        let gx = Math.floor(mx/CFG.tile);

        const dx = gx - Editor.lastX;
        const dy = gy - Editor.lastY;
        const dist = Math.max(Math.abs(dx), Math.abs(dy));

        for (let i = 0; i <= dist; i += CFG.EDITOR_SPAM_RATE) {
            const x = Editor.lastX + Math.round((dx / dist) * i);
            const y = Editor.lastY + Math.round((dy / dist) * i);
            Editor.placeBlock(x, y, Editor.tool);
        }

        Editor.lastX = gx;
        Editor.lastY = gy;
    }
};

window.onmouseup = () => { 
    Input.mousePressed = false;
    Editor.lastX = -1;
    Editor.lastY = -1;
    release(); 
};

// --- Touch Events (FIXED for UI interaction) ---
window.ontouchstart = (e) => {
    if (isUIElement(e.target)) return; // Allow UI elements to handle their own clicks/taps

    // If we are touching the canvas, handle it as game input or editor input
    Input.mousePressed = true;
    
    if (Game.state === 'editor' && e.touches.length === 1) {
        e.preventDefault(); // Prevent scrolling while editing
        const touch = e.touches[0];
        let mx = touch.clientX + Game.camX;
        let gy = Math.floor(-(touch.clientY - (Game.canvas.height - 150))/CFG.tile); 
        let gx = Math.floor(mx/CFG.tile);
        
        Editor.placeBlock(gx, gy, Editor.tool);
        Editor.lastX = gx;
        Editor.lastY = gy;
    }
    // Game action is handled by the dedicated mobile action button via touchStartAction
};

window.ontouchmove = (e) => {
    if(Game.state === 'editor' && Input.mousePressed && Editor.tool === 100 && e.touches.length === 1) {
        e.preventDefault(); 
        
        const touch = e.touches[0];
        let mx = touch.clientX + Game.camX;
        let gy = Math.floor(-(touch.clientY - (Game.canvas.height - 150))/CFG.tile); 
        let gx = Math.floor(mx/CFG.tile);

        const dx = gx - Editor.lastX;
        const dy = gy - Editor.lastY;
        const dist = Math.max(Math.abs(dx), Math.abs(dy));

        for (let i = 0; i <= dist; i += CFG.EDITOR_SPAM_RATE) {
            const x = Editor.lastX + Math.round((dx / dist) * i);
            const y = Editor.lastY + Math.round((dy / dist) * i);
            Editor.placeBlock(x, y, Editor.tool);
        }

        Editor.lastX = gx;
        Editor.lastY = gy;
    }
}

window.ontouchend = () => { 
    Input.mousePressed = false;
    Editor.lastX = -1;
    Editor.lastY = -1;
};

Game.init();
</script>
</body>
</html>
